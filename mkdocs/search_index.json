{
    "docs": [
        {
            "location": "/",
            "text": "Sean Chambers' Portfolio\n\n\nWelcome to my portfolio. The purpose of this portfolio is to exhibit the projects I have built, \nand worked on. Addionally the portfolio provides information on who I am, and contact information.\n\n\nGet Started!",
            "title": "Home"
        },
        {
            "location": "/#sean-chambers-portfolio",
            "text": "Welcome to my portfolio. The purpose of this portfolio is to exhibit the projects I have built, \nand worked on. Addionally the portfolio provides information on who I am, and contact information.  Get Started!",
            "title": "Sean Chambers' Portfolio"
        },
        {
            "location": "/about/",
            "text": "About\n\n\n\n\nWho am I?\n\n\nMy name is Sean Chambers, and I am 21 years of age. I am currently in the final year of my Bachelor of Computer and Information Sciences, \nmajoring in software development. I am a motivated and open-minded individual, eager to learn new skills, innovate, and network with other great minded people. \n\n\n\n\n\n\n\n\n\nCurriculum Vitae",
            "title": "About"
        },
        {
            "location": "/about/#about",
            "text": "",
            "title": "About"
        },
        {
            "location": "/about/#who-am-i",
            "text": "My name is Sean Chambers, and I am 21 years of age. I am currently in the final year of my Bachelor of Computer and Information Sciences, \nmajoring in software development. I am a motivated and open-minded individual, eager to learn new skills, innovate, and network with other great minded people.",
            "title": "Who am I?"
        },
        {
            "location": "/about/#curriculum-vitae",
            "text": "",
            "title": "Curriculum Vitae"
        },
        {
            "location": "/projects/helicoptering/",
            "text": "Projects\n\n\n\n\nHelicoptering (Tech Demo)\n\n\nOverview\n\n\nHelicoptering was an OpenGl tech demo I created during my second year at university. This was programmed in Java, using OpenGl as middleware.\n\n\nThis demo was very basic but gave me good experience with working in a 3D space, rendering shapes, vector math, and physics behaviour.\n\n\nThe helicopter could be controlled using the keyboard. \n\n\nFeatures:\n\nRotor spin up before taking off\n\nDifferent view ports - Top down, and follow\n\nHelicopter pitch, roll, yaw as it flew\n\nRotor wind down once landed\n\nSky sphere\n\nDay/Night Cycle\n\n\n\n\nMiddleware\n\n\nThe middleware implemented. Click each to see website(Opens in new tab).\n\n\nOpenGl\n\n\n\n\n\nScreenshots\n\n\n \n\n\n\n \n\n\n\n\nReferences\n\n\nJogamp.org. (2016). JOGL - Java Binding for the OpenGL API. [online] \n\nAvailable at: http://jogamp.org/jogl/www/ [Accessed 23 Oct. 2016].\n\n\n\n\nCode Snippet\n\n\n/**\n * @author Sean Chambers\n * Base helicopter class assembles the helicopter drawing and animates.\n */\n\npublic class Helicopter {\n    GLUT glut = new GLUT();\n    GLU glu = new GLU();\n\n    //Translate\n    public double tx=0;\n    public double ty=0;\n    public double tz=0;\n\n    //Get ground level at helicopter's x,z location\n    public Ground ground;\n    public double groundLevel =0;\n\n    //Directionals\n    public boolean wKey;\n    public boolean sKey;\n    public boolean aKey;\n    public boolean dKey;\n    public boolean upKey;\n    public boolean downKey;\n    public boolean rightKey;\n    public boolean leftKey;\n    public boolean toggleSpotLight = true;\n\n    //Speeds\n    public double forward;\n    public double strafe;\n    public double altitude;\n\n    //Constants\n    //WASD Inputs\n    public static final double MAX_WASD_SPEED =10;\n    public static final double WASD_SPEED = 5;\n    //Rotation\n    public static final double ROTATION_SPEED = 50;\n    public static final double MAX_ROTATION_SPEED = 100;\n    //Pitch and Roll\n    public static final double ROLL_PITCH_SPEED = 12.5;\n    public static final double MAX_ROLL_PITCH = 25; \n    //Altitude\n    public static final double MAX_ALTITUDE_SPEED = 10;\n    public static final double ALTITUDE_SPEED = 5;  \n    //Rotor speeds\n    public static final double ROTOR_SPEED = 500;\n    public static final double MAX_ROTOR_SPEED = 2000;\n    public static final double LIFT_OFF_SPEED = 1500;\n\n    //Booleans on rotors\n    public boolean power;\n\n    //Rotors\n    public double rotateDeg;\n    public double rotatingSpeed;\n\n    //pitch and roll \n    public double pitch;\n    public double roll;\n\n    //create objects\n\n    //Rotors\n    public Rotor rotors = new Rotor();\n\n    //spotlight\n    public Spotlight spotlight;\n\n    //Textures\n    public Texture bodyTexture;\n\n    //Materials\n    float ambient[] = {0.2f, 0.2f, 0.2f, 1};\n    float diffuse[] = { 1, 0, 0, 1};\n    float specular[] = { 1, 1, 1, 1};\n    float shininess = 100; \n\n\n    public Helicopter(GL gl, Ground ground){\n        try {\n            bodyTexture = TextureIO.newTexture(\n            new File(\"./textures/helicopter_body3.jpg\"), true);\n            } catch ( IOException e ) {\n            }\n        spotlight = new Spotlight(gl);\n        gl.glMaterialfv(GL.GL_FRONT, GL.GL_AMBIENT, ambient, 0);\n        gl.glMaterialfv(GL.GL_FRONT, GL.GL_DIFFUSE, diffuse, 0);\n        gl.glMaterialfv(GL.GL_FRONT, GL.GL_SPECULAR, specular, 0);\n        gl.glMaterialf(GL.GL_FRONT, GL.GL_SHININESS, shininess);\n\n        this.ground = ground;\n    }\n\n    public void animate(double delta){\n\n        //Ground level = the y coordinate of the ground/heightmap*scale + 0.8 (My helicopter's legs.)\n        groundLevel = ground.heightMap[(int) (tx+ground.heightMap.length/2)][(int) (tz+ground.heightMap.length/2)]*100 -50+0.8;\n        //Main rotor speeds + altitude movement.\n        //Increase rotor speed to 2000 then stop increasing.\n        if(power == true)\n            if(rotors.speed < MAX_ROTOR_SPEED)\n                rotors.speed += ROTOR_SPEED*delta;\n\n        //Altitude can be moved once rotors are up to speed.\n        if(rotors.speed > LIFT_OFF_SPEED){\n            if(upKey && altitude < MAX_ALTITUDE_SPEED)\n                altitude += ALTITUDE_SPEED*delta;\n            else if(!upKey && altitude > 0)\n                altitude -= ALTITUDE_SPEED*delta;\n\n            if(downKey && altitude > -1*MAX_ALTITUDE_SPEED)\n                altitude -= ALTITUDE_SPEED*delta;\n            else if(!downKey && altitude < 0)\n                altitude += ALTITUDE_SPEED*delta;\n\n            ty += altitude*delta;\n        }\n\n        //Rotors power down once at ground level\n        if(power == false && rotors.speed > 0)\n            rotors.speed -= ROTOR_SPEED*delta;\n        //Resets helicopter to ground level if it goes below.\n        if(ty < groundLevel)\n            ty = groundLevel;\n\n        //Animate Rotors\n        rotors.animate(delta);\n\n        //Check if helicopter is off the ground every frame.\n        if(ty > groundLevel){   \n            //pitch helicopter\n            if(sKey && pitch < MAX_ROLL_PITCH)\n                pitch += ROLL_PITCH_SPEED*delta;\n            else if(!sKey && pitch > 0)\n                pitch -= ROLL_PITCH_SPEED*delta;\n\n            if(wKey && pitch > -1*MAX_ROLL_PITCH)\n                pitch -= ROLL_PITCH_SPEED*delta;\n            else if(!wKey && pitch < 0)\n                pitch += ROLL_PITCH_SPEED*delta;\n\n            //roll\n            if(aKey && roll < MAX_ROLL_PITCH)\n                roll += ROLL_PITCH_SPEED*delta;\n            else if(!aKey && roll > 0)\n                roll -= ROLL_PITCH_SPEED*delta;\n\n            if(dKey && roll > -1*MAX_ROLL_PITCH)\n                roll -= ROLL_PITCH_SPEED*delta;\n            else if(!dKey && roll < 0)\n                roll += ROLL_PITCH_SPEED*delta; \n\n            //Rotate around Y axis\n            if(leftKey && rotatingSpeed < MAX_ROTATION_SPEED)\n                rotatingSpeed += ROTATION_SPEED*delta;\n            else if(!leftKey && rotatingSpeed > 0)\n                rotatingSpeed -= ROTATION_SPEED*delta;\n\n            if(rightKey && rotatingSpeed > -1*MAX_ROTATION_SPEED)\n                rotatingSpeed -= ROTATION_SPEED*delta;\n            else if(!rightKey && rotatingSpeed < 0)\n                rotatingSpeed += ROTATION_SPEED*delta;\n\n            rotateDeg += rotatingSpeed*delta;\n\n            //Move helicopter forwards and backwards in direction it's facing.\n\n            if(sKey && forward < MAX_WASD_SPEED)\n                forward += WASD_SPEED*delta;\n            if((!sKey && forward > 0) || forward > MAX_WASD_SPEED)\n                forward -= WASD_SPEED*delta;\n\n            if(wKey && forward > -MAX_WASD_SPEED)\n                forward -= WASD_SPEED*delta;\n            if((!wKey && forward < 0) || forward > MAX_WASD_SPEED)\n                forward += WASD_SPEED*delta;\n\n\n\n            //Strafe helicopter reletive to which it faces. \n            if(dKey && strafe < MAX_WASD_SPEED)\n                strafe += WASD_SPEED*delta;\n            if((!dKey && strafe > 0) || strafe > MAX_WASD_SPEED){\n                strafe -= WASD_SPEED*delta;\n            }\n\n            if(aKey && strafe > -MAX_WASD_SPEED)\n                strafe -= WASD_SPEED*delta;\n            if((!aKey && strafe < 0)|| strafe > MAX_WASD_SPEED)\n                strafe += WASD_SPEED*delta;\n\n            tx += forward*(Math.cos(Math.toRadians(rotateDeg-90)))*delta;\n            tz -= forward*(Math.sin(Math.toRadians(rotateDeg-90)))*delta;\n            tx -= strafe*(Math.cos(Math.toRadians(rotateDeg-180)))*delta;   \n            tz += strafe*(Math.sin(Math.toRadians(rotateDeg-180)))*delta;\n\n        }\n        else{\n            //If helicopter hits the ground, then the helicopter is reset.\n            pitch = 0;\n            roll = 0;\n            strafe = 0;\n            forward = 0;\n        }\n\n\n    }\n\n    public void draw(GL gl){    \n        gl.glEnable(GL.GL_COLOR_MATERIAL);\n        gl.glTranslated(tx, ty, tz);\n        //yaw\n        gl.glRotated(rotateDeg, 0 , 1 , 0);\n        //pitch\n        gl.glRotated(pitch, 1 , 0 , 0);\n        //roll\n        gl.glRotated(roll, 0 , 0 , 1);          \n        //BODY\n        gl.glPushMatrix();\n        Material.RedRubber.draw(gl);\n        drawBody(gl);\n        gl.glPopMatrix();\n        //NOSE\n        gl.glPushMatrix();\n        drawNose(gl);\n        gl.glPopMatrix();\n        //TAIL\n        gl.glPushMatrix();\n        drawTail(gl);\n        gl.glPopMatrix();\n        //TAIL FIN\n        gl.glPushMatrix();\n        drawTailFin(gl);\n        gl.glPopMatrix();\n        //LEGS\n        gl.glPushMatrix();\n        drawRightLeg(gl);\n        gl.glPopMatrix();\n        gl.glPushMatrix();\n        drawLeftLeg(gl);\n        gl.glPopMatrix();\n        //FEET\n        gl.glPushMatrix();\n        drawRightFoot(gl);\n        gl.glPopMatrix();   \n        gl.glPushMatrix();\n        drawLeftFoot(gl);\n        gl.glPopMatrix();\n        //ROTOR_KNOB\n        gl.glPushMatrix();\n        rotorKnob(gl);\n        gl.glPopMatrix();\n        //TOP ROTORS\n        gl.glPushMatrix();\n        rotors.draw(gl);\n        gl.glPopMatrix();\n        //TAIL PLUG\n        gl.glPushMatrix();\n        drawTailPlug(gl);\n        gl.glPopMatrix();\n        //TAIL ROTOR KNOB\n        gl.glPushMatrix();\n        drawTailRotorKnob(gl);\n        gl.glPopMatrix();\n        Material.NeutralWhite.draw(gl);\n        //DRAW SPOTLIGHT\n        gl.glPushMatrix();\n        spotlight.draw(gl);     \n        gl.glPopMatrix();\n\n        if(toggleSpotLight)\n            spotlight.enableSpot(gl);\n        else\n            spotlight.disableSpot(gl);\n\n    }   \n    //BODY\n    public void drawBody(GL gl){\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true); \n        glu.gluSphere(body, 0.5,30,10); \n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n\n    }\n\n    //ROTOR_KNOB\n    public void rotorKnob(GL gl){\n        gl.glColor3f(1, 1, 1);\n        gl.glTranslated(0, .675, 0);\n        gl.glRotated(90, 1 , 0 , 0);\n\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true); \n        glu.gluCylinder(body, 0.05, 0.1, 0.2, 15, 5);\n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n    }\n\n    //LEGS\n    public void drawRightLeg(GL gl){\n        gl.glColor3f(.2f, .15f, 0f);\n        gl.glTranslated(0, -0.4 , 0);\n        gl.glRotated(90, 0, 1 , 0);\n        gl.glRotated(45, 1 , 0 , 0);\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluCylinder(body, .05, .05, .5, 25, 5);\n\n    }\n\n    public void drawLeftLeg(GL gl){\n        gl.glColor3f(.2f, .15f, 0f);\n        gl.glTranslated(0, -0.4 , 0);\n        gl.glRotated(270, 0, 1 , 0);\n        gl.glRotated(45, 1 , 0 , 0);\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluCylinder(body, .05, .05, .5, 25, 5);\n\n    }\n    //FEET\n    public void drawRightFoot(GL gl){\n        gl.glColor3f(1,1,1);\n        gl.glTranslated(0.35, -0.75, 0);\n        gl.glScaled(0.075,.075, 1);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        glut.glutSolidCube(1);  \n        bodyTexture.disable();\n\n    }\n\n    public void drawLeftFoot(GL gl){\n        gl.glColor3f(1,1,1);\n        gl.glTranslated(-0.35, -0.75, 0);\n        gl.glScaled(0.075,.075, 1);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        glut.glutSolidCube(1);  \n        bodyTexture.disable();\n\n    }\n\n    //NOSE\n    public void drawNose(GL gl){\n        gl.glTranslated(0, 0, -0.3);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true);\n        glu.gluCylinder(body, 0.4, 0, -.5, 25, 5);  \n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n\n    }\n\n    //TAIL\n    public void drawTail(GL gl){\n        gl.glTranslated(0, 0, .4);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true);\n        glu.gluCylinder(body, 0.25, 0.1, 2, 15, 5);\n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n\n    }\n\n    //TAIL FIN\n    public void drawTailFin(GL gl){\n        gl.glTranslated(0, 0.1, 2.3);\n        gl.glScaled(0.1,.6,0.2);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        glut.glutSolidCube(1);  \n        bodyTexture.disable();\n    }\n\n    //TAIL ROTOR KNOB\n    public void drawTailRotorKnob(GL gl){\n        gl.glTranslated(0.0, 0, 2.3);\n        gl.glRotated(90, 0 , 1 , 0);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true); \n        glu.gluCylinder(body, 0.08, 0.025, 0.2, 15, 5);\n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n\n\n    }\n\n    //TAIL PLUG\n    public void drawTailPlug(GL gl){\n\n        gl.glTranslated(0, 0.0, 2.4);   \n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true);\n        glu.gluSphere(body, .1,30,10);  \n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n    }\n\n}",
            "title": "Helicoptering"
        },
        {
            "location": "/projects/helicoptering/#projects",
            "text": "",
            "title": "Projects"
        },
        {
            "location": "/projects/helicoptering/#helicoptering-tech-demo",
            "text": "",
            "title": "Helicoptering (Tech Demo)"
        },
        {
            "location": "/projects/helicoptering/#overview",
            "text": "Helicoptering was an OpenGl tech demo I created during my second year at university. This was programmed in Java, using OpenGl as middleware.  This demo was very basic but gave me good experience with working in a 3D space, rendering shapes, vector math, and physics behaviour.  The helicopter could be controlled using the keyboard.   Features: Rotor spin up before taking off Different view ports - Top down, and follow Helicopter pitch, roll, yaw as it flew Rotor wind down once landed Sky sphere Day/Night Cycle",
            "title": "Overview"
        },
        {
            "location": "/projects/helicoptering/#middleware",
            "text": "The middleware implemented. Click each to see website(Opens in new tab).  OpenGl",
            "title": "Middleware"
        },
        {
            "location": "/projects/helicoptering/#screenshots",
            "text": "",
            "title": "Screenshots"
        },
        {
            "location": "/projects/helicoptering/#references",
            "text": "Jogamp.org. (2016). JOGL - Java Binding for the OpenGL API. [online]  Available at: http://jogamp.org/jogl/www/ [Accessed 23 Oct. 2016].",
            "title": "References"
        },
        {
            "location": "/projects/helicoptering/#code-snippet",
            "text": "/**\n * @author Sean Chambers\n * Base helicopter class assembles the helicopter drawing and animates.\n */\n\npublic class Helicopter {\n    GLUT glut = new GLUT();\n    GLU glu = new GLU();\n\n    //Translate\n    public double tx=0;\n    public double ty=0;\n    public double tz=0;\n\n    //Get ground level at helicopter's x,z location\n    public Ground ground;\n    public double groundLevel =0;\n\n    //Directionals\n    public boolean wKey;\n    public boolean sKey;\n    public boolean aKey;\n    public boolean dKey;\n    public boolean upKey;\n    public boolean downKey;\n    public boolean rightKey;\n    public boolean leftKey;\n    public boolean toggleSpotLight = true;\n\n    //Speeds\n    public double forward;\n    public double strafe;\n    public double altitude;\n\n    //Constants\n    //WASD Inputs\n    public static final double MAX_WASD_SPEED =10;\n    public static final double WASD_SPEED = 5;\n    //Rotation\n    public static final double ROTATION_SPEED = 50;\n    public static final double MAX_ROTATION_SPEED = 100;\n    //Pitch and Roll\n    public static final double ROLL_PITCH_SPEED = 12.5;\n    public static final double MAX_ROLL_PITCH = 25; \n    //Altitude\n    public static final double MAX_ALTITUDE_SPEED = 10;\n    public static final double ALTITUDE_SPEED = 5;  \n    //Rotor speeds\n    public static final double ROTOR_SPEED = 500;\n    public static final double MAX_ROTOR_SPEED = 2000;\n    public static final double LIFT_OFF_SPEED = 1500;\n\n    //Booleans on rotors\n    public boolean power;\n\n    //Rotors\n    public double rotateDeg;\n    public double rotatingSpeed;\n\n    //pitch and roll \n    public double pitch;\n    public double roll;\n\n    //create objects\n\n    //Rotors\n    public Rotor rotors = new Rotor();\n\n    //spotlight\n    public Spotlight spotlight;\n\n    //Textures\n    public Texture bodyTexture;\n\n    //Materials\n    float ambient[] = {0.2f, 0.2f, 0.2f, 1};\n    float diffuse[] = { 1, 0, 0, 1};\n    float specular[] = { 1, 1, 1, 1};\n    float shininess = 100; \n\n\n    public Helicopter(GL gl, Ground ground){\n        try {\n            bodyTexture = TextureIO.newTexture(\n            new File(\"./textures/helicopter_body3.jpg\"), true);\n            } catch ( IOException e ) {\n            }\n        spotlight = new Spotlight(gl);\n        gl.glMaterialfv(GL.GL_FRONT, GL.GL_AMBIENT, ambient, 0);\n        gl.glMaterialfv(GL.GL_FRONT, GL.GL_DIFFUSE, diffuse, 0);\n        gl.glMaterialfv(GL.GL_FRONT, GL.GL_SPECULAR, specular, 0);\n        gl.glMaterialf(GL.GL_FRONT, GL.GL_SHININESS, shininess);\n\n        this.ground = ground;\n    }\n\n    public void animate(double delta){\n\n        //Ground level = the y coordinate of the ground/heightmap*scale + 0.8 (My helicopter's legs.)\n        groundLevel = ground.heightMap[(int) (tx+ground.heightMap.length/2)][(int) (tz+ground.heightMap.length/2)]*100 -50+0.8;\n        //Main rotor speeds + altitude movement.\n        //Increase rotor speed to 2000 then stop increasing.\n        if(power == true)\n            if(rotors.speed < MAX_ROTOR_SPEED)\n                rotors.speed += ROTOR_SPEED*delta;\n\n        //Altitude can be moved once rotors are up to speed.\n        if(rotors.speed > LIFT_OFF_SPEED){\n            if(upKey && altitude < MAX_ALTITUDE_SPEED)\n                altitude += ALTITUDE_SPEED*delta;\n            else if(!upKey && altitude > 0)\n                altitude -= ALTITUDE_SPEED*delta;\n\n            if(downKey && altitude > -1*MAX_ALTITUDE_SPEED)\n                altitude -= ALTITUDE_SPEED*delta;\n            else if(!downKey && altitude < 0)\n                altitude += ALTITUDE_SPEED*delta;\n\n            ty += altitude*delta;\n        }\n\n        //Rotors power down once at ground level\n        if(power == false && rotors.speed > 0)\n            rotors.speed -= ROTOR_SPEED*delta;\n        //Resets helicopter to ground level if it goes below.\n        if(ty < groundLevel)\n            ty = groundLevel;\n\n        //Animate Rotors\n        rotors.animate(delta);\n\n        //Check if helicopter is off the ground every frame.\n        if(ty > groundLevel){   \n            //pitch helicopter\n            if(sKey && pitch < MAX_ROLL_PITCH)\n                pitch += ROLL_PITCH_SPEED*delta;\n            else if(!sKey && pitch > 0)\n                pitch -= ROLL_PITCH_SPEED*delta;\n\n            if(wKey && pitch > -1*MAX_ROLL_PITCH)\n                pitch -= ROLL_PITCH_SPEED*delta;\n            else if(!wKey && pitch < 0)\n                pitch += ROLL_PITCH_SPEED*delta;\n\n            //roll\n            if(aKey && roll < MAX_ROLL_PITCH)\n                roll += ROLL_PITCH_SPEED*delta;\n            else if(!aKey && roll > 0)\n                roll -= ROLL_PITCH_SPEED*delta;\n\n            if(dKey && roll > -1*MAX_ROLL_PITCH)\n                roll -= ROLL_PITCH_SPEED*delta;\n            else if(!dKey && roll < 0)\n                roll += ROLL_PITCH_SPEED*delta; \n\n            //Rotate around Y axis\n            if(leftKey && rotatingSpeed < MAX_ROTATION_SPEED)\n                rotatingSpeed += ROTATION_SPEED*delta;\n            else if(!leftKey && rotatingSpeed > 0)\n                rotatingSpeed -= ROTATION_SPEED*delta;\n\n            if(rightKey && rotatingSpeed > -1*MAX_ROTATION_SPEED)\n                rotatingSpeed -= ROTATION_SPEED*delta;\n            else if(!rightKey && rotatingSpeed < 0)\n                rotatingSpeed += ROTATION_SPEED*delta;\n\n            rotateDeg += rotatingSpeed*delta;\n\n            //Move helicopter forwards and backwards in direction it's facing.\n\n            if(sKey && forward < MAX_WASD_SPEED)\n                forward += WASD_SPEED*delta;\n            if((!sKey && forward > 0) || forward > MAX_WASD_SPEED)\n                forward -= WASD_SPEED*delta;\n\n            if(wKey && forward > -MAX_WASD_SPEED)\n                forward -= WASD_SPEED*delta;\n            if((!wKey && forward < 0) || forward > MAX_WASD_SPEED)\n                forward += WASD_SPEED*delta;\n\n\n\n            //Strafe helicopter reletive to which it faces. \n            if(dKey && strafe < MAX_WASD_SPEED)\n                strafe += WASD_SPEED*delta;\n            if((!dKey && strafe > 0) || strafe > MAX_WASD_SPEED){\n                strafe -= WASD_SPEED*delta;\n            }\n\n            if(aKey && strafe > -MAX_WASD_SPEED)\n                strafe -= WASD_SPEED*delta;\n            if((!aKey && strafe < 0)|| strafe > MAX_WASD_SPEED)\n                strafe += WASD_SPEED*delta;\n\n            tx += forward*(Math.cos(Math.toRadians(rotateDeg-90)))*delta;\n            tz -= forward*(Math.sin(Math.toRadians(rotateDeg-90)))*delta;\n            tx -= strafe*(Math.cos(Math.toRadians(rotateDeg-180)))*delta;   \n            tz += strafe*(Math.sin(Math.toRadians(rotateDeg-180)))*delta;\n\n        }\n        else{\n            //If helicopter hits the ground, then the helicopter is reset.\n            pitch = 0;\n            roll = 0;\n            strafe = 0;\n            forward = 0;\n        }\n\n\n    }\n\n    public void draw(GL gl){    \n        gl.glEnable(GL.GL_COLOR_MATERIAL);\n        gl.glTranslated(tx, ty, tz);\n        //yaw\n        gl.glRotated(rotateDeg, 0 , 1 , 0);\n        //pitch\n        gl.glRotated(pitch, 1 , 0 , 0);\n        //roll\n        gl.glRotated(roll, 0 , 0 , 1);          \n        //BODY\n        gl.glPushMatrix();\n        Material.RedRubber.draw(gl);\n        drawBody(gl);\n        gl.glPopMatrix();\n        //NOSE\n        gl.glPushMatrix();\n        drawNose(gl);\n        gl.glPopMatrix();\n        //TAIL\n        gl.glPushMatrix();\n        drawTail(gl);\n        gl.glPopMatrix();\n        //TAIL FIN\n        gl.glPushMatrix();\n        drawTailFin(gl);\n        gl.glPopMatrix();\n        //LEGS\n        gl.glPushMatrix();\n        drawRightLeg(gl);\n        gl.glPopMatrix();\n        gl.glPushMatrix();\n        drawLeftLeg(gl);\n        gl.glPopMatrix();\n        //FEET\n        gl.glPushMatrix();\n        drawRightFoot(gl);\n        gl.glPopMatrix();   \n        gl.glPushMatrix();\n        drawLeftFoot(gl);\n        gl.glPopMatrix();\n        //ROTOR_KNOB\n        gl.glPushMatrix();\n        rotorKnob(gl);\n        gl.glPopMatrix();\n        //TOP ROTORS\n        gl.glPushMatrix();\n        rotors.draw(gl);\n        gl.glPopMatrix();\n        //TAIL PLUG\n        gl.glPushMatrix();\n        drawTailPlug(gl);\n        gl.glPopMatrix();\n        //TAIL ROTOR KNOB\n        gl.glPushMatrix();\n        drawTailRotorKnob(gl);\n        gl.glPopMatrix();\n        Material.NeutralWhite.draw(gl);\n        //DRAW SPOTLIGHT\n        gl.glPushMatrix();\n        spotlight.draw(gl);     \n        gl.glPopMatrix();\n\n        if(toggleSpotLight)\n            spotlight.enableSpot(gl);\n        else\n            spotlight.disableSpot(gl);\n\n    }   \n    //BODY\n    public void drawBody(GL gl){\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true); \n        glu.gluSphere(body, 0.5,30,10); \n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n\n    }\n\n    //ROTOR_KNOB\n    public void rotorKnob(GL gl){\n        gl.glColor3f(1, 1, 1);\n        gl.glTranslated(0, .675, 0);\n        gl.glRotated(90, 1 , 0 , 0);\n\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true); \n        glu.gluCylinder(body, 0.05, 0.1, 0.2, 15, 5);\n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n    }\n\n    //LEGS\n    public void drawRightLeg(GL gl){\n        gl.glColor3f(.2f, .15f, 0f);\n        gl.glTranslated(0, -0.4 , 0);\n        gl.glRotated(90, 0, 1 , 0);\n        gl.glRotated(45, 1 , 0 , 0);\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluCylinder(body, .05, .05, .5, 25, 5);\n\n    }\n\n    public void drawLeftLeg(GL gl){\n        gl.glColor3f(.2f, .15f, 0f);\n        gl.glTranslated(0, -0.4 , 0);\n        gl.glRotated(270, 0, 1 , 0);\n        gl.glRotated(45, 1 , 0 , 0);\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluCylinder(body, .05, .05, .5, 25, 5);\n\n    }\n    //FEET\n    public void drawRightFoot(GL gl){\n        gl.glColor3f(1,1,1);\n        gl.glTranslated(0.35, -0.75, 0);\n        gl.glScaled(0.075,.075, 1);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        glut.glutSolidCube(1);  \n        bodyTexture.disable();\n\n    }\n\n    public void drawLeftFoot(GL gl){\n        gl.glColor3f(1,1,1);\n        gl.glTranslated(-0.35, -0.75, 0);\n        gl.glScaled(0.075,.075, 1);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        glut.glutSolidCube(1);  \n        bodyTexture.disable();\n\n    }\n\n    //NOSE\n    public void drawNose(GL gl){\n        gl.glTranslated(0, 0, -0.3);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true);\n        glu.gluCylinder(body, 0.4, 0, -.5, 25, 5);  \n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n\n    }\n\n    //TAIL\n    public void drawTail(GL gl){\n        gl.glTranslated(0, 0, .4);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true);\n        glu.gluCylinder(body, 0.25, 0.1, 2, 15, 5);\n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n\n    }\n\n    //TAIL FIN\n    public void drawTailFin(GL gl){\n        gl.glTranslated(0, 0.1, 2.3);\n        gl.glScaled(0.1,.6,0.2);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        glut.glutSolidCube(1);  \n        bodyTexture.disable();\n    }\n\n    //TAIL ROTOR KNOB\n    public void drawTailRotorKnob(GL gl){\n        gl.glTranslated(0.0, 0, 2.3);\n        gl.glRotated(90, 0 , 1 , 0);\n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true); \n        glu.gluCylinder(body, 0.08, 0.025, 0.2, 15, 5);\n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n\n\n    }\n\n    //TAIL PLUG\n    public void drawTailPlug(GL gl){\n\n        gl.glTranslated(0, 0.0, 2.4);   \n        bodyTexture.enable();\n        bodyTexture.bind();\n        GLUquadric body = glu.gluNewQuadric();\n        glu.gluQuadricTexture(body, true);\n        glu.gluSphere(body, .1,30,10);  \n        glu.gluQuadricTexture(body, false);\n        bodyTexture.disable();\n    }\n\n}",
            "title": "Code Snippet"
        },
        {
            "location": "/projects/warehouse/",
            "text": "Projects\n\n\n\n\nWarehouse Escape (Solo Project)\n\n\nOverview\n\n\nWarehouse escape is a top-down 2D shooter/strategy game built on COMP710 GP 2D Framework (Game framework created by Steffan Hooper), coded in C++ .\nYou are a cardboard box filled with goods stuck in warehouse. It is your goal to escape by making your way through \nthe warehouse without being caught and jump into the back of the delivery truck to get out of there!\n\n\nThe enemy employees will attempt to catch you, if you are within their range. They will move quickly. If they collide \nwith you then you will be reset. You also have the option kill the enemies by throwing smaller boxes at them, but \nare limited to amount of ammo. If an employee is to catch you, you will respawn back at the start after 5 seconds.\n\n\nEvery escape attempt will be recorded. \n\n\nThe quicker the player reaches the end; the more points they will be rewarded.\n\n\n\n\n\nTo see more, view the Game Design Document & Techinical Design Document, below in the files section.\n\n\n\n\nMiddleware\n\n\nThe middlewares' implemented. Click each to see website(Opens in new tab).\n\n\nBox2D\n\n\n\nSDL\n\n\n\nFMOD\n\n\n\n\n\nControls\n\n\n\n\n\n\nScreenshots\n\n\n \n\n\n\n\n\n\nReflection\n\n\nOverview:\n\nThis project has been a great learning experience for myself. At first I found it very overwhelming, due to have doing majority \nof my programming in Java.   This project has been a massive learning curve for myself. Throughout the development of \nWarehouse Escape, I utilised the lecture slides, google, and the discussion forum to solve any programming issues that arose. \nDuring development I was fortunate enough to have my flatmate\u2019s test my game as it was being developed. This was very useful for \nfinding bugs, and also great for getting general feedback. \n\n\nI feel good with the end result. I do however regret not making a more fun side-scroller, rather than the top-down game that it \nis. The game has no memory leaks, bugs, crashes, warnings, and can be restarted, paused, and quit. The quality of the code \ncould be improved, however due to time constraints, I felt the extra time I had would be better adding more features, and making \na gold build because it ran fine. The goal of the game is still the same as mentioned in the design phase. However, some features \nwere change during development, and some were not included.\n\n\nChallenges:\n\nBox2D collision offsets - One issue I ran into was the Box2D colliders not being at the same location as my sprites. This was because\nthe sprites were being placed from the middle, and my colliders were not. I solved this by applying the same logic using to place the\nsprites from the middle to the colliders. \n\n\nDrawing text to the screen caused me a bit of trouble, and was not drawing. I solved this by using the discussion forum provided by my \nlecturer, Steffan Hooper, as other students were having similar problems. \n\n\nAnother challenge I faced was collision filtering. I knew what logic I wanted my game to apply, but I needed to use Box2D's filtering\nsystem to solve this challenge. I spent some time researching; reading through the Box2D manual, and viewing other's problems on the \ninternet. Then I was able to apply what I had read into my game. Having collision filtering was essential to this game because I wanted\ndifferent entities to interact differently with each other, in terms of collision.\n\n\nWhat I would do different next time:\n\nIn future projects, I would like to create a resource manager. This way all assets needed will be loaded into the game on launch, then can be\naccessed by all classes until the game is closed. Additionally, in future projects, I will be making more time to make games more data driven.\n\n\nI would like to upskill more before taking on projects in the future, as I did not upskill enough before using Box2D. This resulted\nin me using development time to upskill.\n\n\nAdding keyboard and mouse support for future games will definitely be implemented.\n\n\n\n\nFiles\n\n\nGame Design Document\n\n\nTechinical Design Document\n\n\nReflection\n\n\n\n\nReferences\n\n\nCatto, E. (2015). Box2D | A 2D Physics Engine for Games. [online] Box2d.org.\n \nAvailable at: http://box2d.org/ [Accessed 23 Oct. 2016].\n\n\nFmod.org. (2016). FMOD. [online]\n \nAvailable at: http://www.fmod.org/ [Accessed 23 Oct. 2016].\n\n\nYouTube. (2016). NoCopyrightSounds. [online] \n\nAvailable at: https://www.youtube.com/user/NoCopyrightSounds [Accessed 23 Oct. 2016].\n\n\nOpenGameArt.org. (2016). OpenGameArt.org. [online] \n\nAvailable at: http://opengameart.org/ [Accessed 23 Oct. 2016].\n\n\nLibsdl.org. (2016). Simple DirectMedia Layer - Homepage. [online] \n\nAvailable at: https://www.libsdl.org/ [Accessed 23 Oct. 2016].\n\n\n\n\nCode Snippet\n\n\n// COMP710 GP 2D Framework\n\n// This includes:\n#include \"game.h\"\n\n// Local includes:\n#include \"backbuffer.h\"\n#include \"inputhandler.h\"\n#include \"logmanager.h\"\n#include \"Texture.h\"\n#include \"sprite.h\"\n#include \"AnimatedSprite.h\"\n#include \"entity.h\"\n#include \"PlayerShip.h\"\n#include \"Enemy.h\"\n#include \"Bullet.h\"\n#include \"background.h\"\n#include \"Box2D.h\"\n#include \"staticObject.h\"\n#include \"Menu.h\"\n\n// Library includes:\n#include <cassert>\n#include <SDL.h>\n#include <SDL_ttf.h>\n\n// Static Members:\nGame* Game::sm_pInstance = 0;\n\nGame&\nGame::GetInstance()\n{\n    if (sm_pInstance == 0)\n    { \n        sm_pInstance = new Game();\n    }\n\n    assert(sm_pInstance);\n\n    return (*sm_pInstance);\n}\n\nvoid \nGame::DestroyInstance()\n{\n    delete sm_pInstance; \n    sm_pInstance = 0;\n\n}\n\nGame::Game()\n: m_pBackBuffer(0)\n, m_pInputHandler(0)\n, m_looping(true)\n, m_executionTime(0)\n, m_elapsedSeconds(0)\n, m_frameCount(0)\n, m_FPS(0)\n, m_numUpdates(0)\n, m_lastTime(0)\n, m_lag(0)\n{\n\n}\n\nGame::~Game()\n{\n    //delete entities\n    for (auto i = bullets.begin(); i != bullets.end(); ++i)\n        delete *i;\n\n    for (auto x = enemies.begin(); x != enemies.end(); ++x)\n        delete *x;\n\n    for (auto y = staticObjects.begin(); y != staticObjects.end(); y++)\n        delete *y;\n\n    animatedBullet->~AnimatedSprite();\n    enemyChaseTexture->~Texture();\n\n    //release audio\n    if (!backgroundMusicReleased)\n        backgroundMusic->release();\n    winSound->release();\n    stunSound->release();\n    menuButtonSound->release();\n    hitEnemy->release();\n    spotEnemy->release();\n    hitWall->release();\n\n    //Background/Map\n\n\n    //other\n    delete m_pInputHandler;\n    m_pInputHandler = 0;    \n\n    delete world;\n    world = 0;\n\n    delete m_pBackBuffer;\n    m_pBackBuffer = 0;\n\n    //Delete sprites\n    delete mapSprite;\n    mapSprite = 0;\n\n    delete background;\n    background = 0;\n\n    delete playerSprite;\n    playerSprite = 0;\n\n    delete playerShip;\n    playerShip = 0;\n\n    delete startScreen;\n    startScreen = 0;\n\n    delete animatedBullet;\n    animatedBullet = 0;\n\n    delete blockSprite;\n    blockSprite = 0;\n\n    //MENU\n    delete m_menu;\n    m_menu = 0;\n\n    soundSystem->release();\n}\n\nbool \nGame::Initialise()\n{\n    m_pBackBuffer = new BackBuffer();\n    if (!m_pBackBuffer->Initialise(SCREEN_WIDTH, SCREEN_HEIGHT))\n    {\n        LogManager::GetInstance().Log(\"BackBuffer Init Fail!\");\n        return (false);\n    }\n\n    m_pInputHandler = new InputHandler();\n    if (!m_pInputHandler->Initialise())\n    {\n        LogManager::GetInstance().Log(\"InputHandler Init Fail!\");\n        return (false);\n    }\n\n    controllerMode = STARTSCREEN;\n\n    //MENU\n    m_menu = new Menu();\n    m_menu->Initialise(m_pBackBuffer, SCREEN_WIDTH, SCREEN_HEIGHT);\n\n    //SOUND\n    // Create the sound system object.\n    FMOD::System_Create(&soundSystem);\n    // Initialize the sound system object.\n    soundSystem->init(512, FMOD_INIT_NORMAL, 0);\n\n    //Initialize background music, and play.\n    soundSystem->createSound(\"assets\\\\sounds\\\\btfragout.mp3\", FMOD_DEFAULT, 0, &backgroundMusic);\n    backgroundMusic->setMode(FMOD_LOOP_NORMAL);\n    soundSystem->playSound(backgroundMusic, 0, true, &channel0);\n    channel0->setVolume(0.1f);\n    channel0->setPaused(false);\n\n    //Initialize other sounds\n    soundSystem->createSound(\"assets\\\\sounds\\\\shoot01.flac\", FMOD_DEFAULT, 0, &stunSound);\n    stunSound->setMode(FMOD_LOOP_OFF);\n    soundSystem->createSound(\"assets\\\\sounds\\\\hitWall.flac\", FMOD_DEFAULT, 0, &hitWall);\n    hitWall->setMode(FMOD_LOOP_OFF);\n    soundSystem->createSound(\"assets\\\\sounds\\\\wincloud9.mp3\", FMOD_DEFAULT, 0, &winSound);\n    winSound->setMode(FMOD_LOOP_OFF);\n    soundSystem->createSound(\"assets\\\\sounds\\\\menuSelection.wav\", FMOD_DEFAULT, 0, &menuButtonSound);\n    menuButtonSound->setMode(FMOD_LOOP_OFF);\n\n    //START SCREEN\n    startScreen = m_pBackBuffer->CreateSprite(\"assets\\\\sprites\\\\playScreen2.png\");\n    startScreen->SetX(SCREEN_WIDTH/2);\n    startScreen->SetY(SCREEN_HEIGHT/2);\n\n    //MAP\n    //Load wall sprite\n    wallTexture = m_pBackBuffer->CreateTexture(\"assets\\\\sprites\\\\blackWall01.png\");\n    blockSprite = m_pBackBuffer->CreateSprite(wallTexture);\n\n    //Spawn outer walls\n    SpawnMapBlock(wallTexture,world,true,800, 10, SCREEN_WIDTH/2, SCREEN_HEIGHT-5);\n    SpawnMapBlock(wallTexture, world, true, 800, 10, SCREEN_WIDTH / 2, 5);\n    SpawnMapBlock(wallTexture, world, true, 10, 600, SCREEN_WIDTH - 5, SCREEN_HEIGHT / 2);\n    SpawnMapBlock(wallTexture, world, true, 10, 600, 5, SCREEN_HEIGHT / 2);\n    //spawn inner walls (Truck Wall)\n    SpawnMapBlock(wallTexture, world, true, 10, 510, SCREEN_WIDTH - 137, SCREEN_HEIGHT / 2 - 36);\n    SpawnMapBlock(wallTexture, world, true, 10, 30, SCREEN_WIDTH - 137, SCREEN_HEIGHT / 2 + 275);\n    //spawn inner walls\n    SpawnMapBlock(wallTexture, world, false,20, 500, 100, SCREEN_HEIGHT / 2 + 50);\n    SpawnMapBlock(wallTexture, world, false, 400, 30, 380, 115);\n    SpawnMapBlock(wallTexture, world, false, 400, 60, 380, 215);\n    SpawnMapBlock(wallTexture, world, false, 30, 200, 195, 415);\n    SpawnMapBlock(wallTexture, world, false, 30, 200, 295, 415);\n    SpawnMapBlock(wallTexture, world, false, 400, 30, 380, 415);\n    SpawnMapBlock(wallTexture, world, false, 150, 30, 460, 330);\n    SpawnMapBlock(wallTexture, world, false, 150, 30, 460, 500);\n\n    //Initialize s\n    mapSprite = m_pBackBuffer->CreateSprite(\"assets\\\\sprites\\\\background2.png\");\n    background = new Background(0, 0);\n    background->Initialise(mapSprite);\n\n    //PLAYER\n    //Load the player sprite.\n    playerSprite = m_pBackBuffer->CreateSprite(\"assets\\\\sprites\\\\playerBox.png\");\n    //Create the player instance.\n    playerShip = new PlayerShip(world, 50, 550);\n    playerShip->Initialise(playerSprite);\n\n    //BULLET\n    animatedBullet = m_pBackBuffer->CreateAnimatedSprite(\"assets\\\\sprites\\\\cardboardBullet02.png\");\n\n    //ENEMIES\n    //load enemy sprite\n    enemyTexture = m_pBackBuffer->CreateTexture(\"assets\\\\sprites\\\\enemyIdle.png\");\n    enemyChaseTexture = m_pBackBuffer->CreateTexture(\"assets\\\\sprites\\\\enemyChase.png\");\n    soundSystem->createSound(\"assets\\\\sounds\\\\hitEnemy.flac\", FMOD_DEFAULT, 0, &hitEnemy);\n    soundSystem->createSound(\"assets\\\\sounds\\\\huh.wav\", FMOD_DEFAULT, 0, &spotEnemy);\n\n    //spawn enemies..\n    SpawnEnemy(enemyTexture, world, 300, 50);\n    SpawnEnemy(enemyTexture, world, 300, 280);\n    SpawnEnemy(enemyTexture, world, 300, 150);\n    SpawnEnemy(enemyTexture, world, 450, 280);\n    SpawnEnemy(enemyTexture, world, 300, 575);\n\n    //Set Timer to default values\n    ResetTimer();\n\n    m_lastTime = SDL_GetTicks();\n    m_lag = 0.0f;\n    return (true);\n}\n\nbool \nGame::DoGameLoop()\n{\n    const float stepSize = 1.0f / 60.0f;\n    assert(m_pInputHandler);\n    m_pInputHandler->ProcessInput(*this);\n\n    if (m_looping)\n    {\n        int current = SDL_GetTicks();\n        float deltaTime = (current - m_lastTime) / 1000.0f;\n        m_lastTime = current;\n        m_executionTime += deltaTime;\n        m_lag += deltaTime;\n        while (m_lag >= stepSize)\n        {\n            //If game is not paused then process as normal\n            if (!gamePaused && !inStartScreen)\n            {\n                world->Step(stepSize, 6, 6);\n                Process(stepSize);\n            }\n            //if game is paused freeze simulation   \n            else\n            {\n                Process(0);\n                world->Step(0, 0, 0);\n            }       \n            m_lag -= stepSize;\n            ++m_numUpdates;\n        }\n        Draw(*m_pBackBuffer);\n    }\n\n    //If the game is paused, then pause all audio\n    if (!gamePaused)\n        soundSystem->update();\n\n    SDL_Delay(1);\n    return (m_looping);\n}\n\nvoid \nGame::Process(float deltaTime)\n{\n        // Count total simulation time elapsed:\n        m_elapsedSeconds += deltaTime;\n\n        // Frame Counter\n        if (m_elapsedSeconds > 1)\n        {\n            m_elapsedSeconds -= 1;\n            m_FPS = m_frameCount;\n            m_frameCount = 0;\n        }\n        //has player won?\n        CheckPlayerWin();\n\n        //if game is not finished, then process.\n        if (!gameFinished)\n        {\n            // W02.3: Process each bullet in the container.\n            for (Bullet* currentBullet : bullets)\n            {\n                if (currentBullet->IsDead() == false)\n                    currentBullet->Process(deltaTime);\n            }\n\n            //process each enemy in container\n            for (Enemy* enemy : enemies)\n            if (enemy->IsDead() == false)\n                enemy->Process(deltaTime);\n\n            GameTimer(deltaTime);\n        }\n\n        playerShip->Process(deltaTime);\n\n        //Remove any dead bullets from the container...\n        std::vector<Bullet*>::iterator bulletIter;\n        bulletIter = bullets.begin();\n        while (bulletIter != bullets.end())\n        {\n            Bullet* currentBullet = *bulletIter;\n            if (currentBullet->IsDead())\n            {\n                bulletIter = bullets.erase(bulletIter);\n                delete currentBullet;\n            }\n            else\n                ++bulletIter;\n        }\n\n        bullets.shrink_to_fit();\n\n        //Remove dead enemies from container\n        std::vector<Enemy*>::iterator enemyIter;\n        enemyIter = enemies.begin();\n        while (enemyIter != enemies.end())\n        {\n            Enemy* currentEnemy = *enemyIter;\n            if (currentEnemy->IsDead())\n            {\n                enemyIter = enemies.erase(enemyIter);\n                delete currentEnemy;\n            }\n            else\n                ++enemyIter;\n        }\n        enemies.shrink_to_fit();\n}\n\nvoid \nGame::Draw(BackBuffer& backBuffer)\n{\n    ++m_frameCount;\n    backBuffer.Clear();\n\n    //Draw background\n    background->Draw(backBuffer);\n\n    //draw static objects\n    for (StaticObject* obj : staticObjects)\n        if (obj->draw == true)\n            obj->Draw(backBuffer);\n\n    //Draw start screen\n    if (inStartScreen)\n        startScreen->Draw(backBuffer);\n    else\n    {\n        //draw enemies\n        for (Enemy* enemy : enemies)\n            enemy->Draw(backBuffer);\n\n        // W02.3: Draw all bullets in container...\n        for (Bullet* currentBullet : bullets)\n            currentBullet->Draw(backBuffer);\n\n        //Draw the player...\n        playerShip->Draw(backBuffer);\n\n        if (gamePaused)\n            m_menu->Draw(backBuffer);\n        if (gameFinished)\n        {\n            backBuffer.DrawText(false, \"You win!\", SCREEN_WIDTH / 2 - 90, SCREEN_HEIGHT / 2 - 200);\n        }\n\n        //Draw Attempts by player\n        backBuffer.DrawText(true, \"Attempts:\", 10, 12);\n        backBuffer.DrawText(true, playerShip->getPlayerAttempts(), 110, 14);\n        backBuffer.DrawText(true, \"Ammo:\", 10, 32);\n        backBuffer.DrawText(true, playerShip->printBulletNumber(), 110, 32);\n\n        //Score\n        backBuffer.DrawText(true, playerShip->getPlayerScore(), 675, 76);\n\n        //Draw Timer\n        backBuffer.DrawText(true, \"Time:\", 700, 12);\n        backBuffer.DrawText(true, \"_____\", 700, 12);\n        backBuffer.DrawText(true, \"Min:\", 675, 36);\n        backBuffer.DrawText(true, this->currentMinute, 745, 36);\n        backBuffer.DrawText(true, \"Sec:\", 675, 56);\n        backBuffer.DrawText(true, this->currentSecond, 745, 56);\n    }\n\n    backBuffer.Present();   \n}\n\nvoid \nGame::Quit()\n{\n    m_looping = false;\n}\nvoid\nGame::StartGame()\n{       \n    inStartScreen = false;\n    controllerMode = INGAME;\n}\n\n//Player directionals\n//Move player horizontally \nvoid \nGame::MovePlayerLeft(int input)\n{\n    playerShip->setXInput((float)input);\n}\n//move player vertically\nvoid\nGame::MovePlayerUp(int input)\n{\n    playerShip->setYInput((float)input);\n}\n\n//Spawn bullet\nvoid \nGame::FireStun(float x, float y)\n{\n        //if game is not finished\n        if (!gameFinished)\n        {\n            if (playerShip->getBulletCount() > 0)\n            {   \n                //Create a new bullet object.\n                bullet = new Bullet(world, soundSystem, hitWall, playerShip->GetPositionX(), playerShip->GetPositionY());\n                bullet->Initialise(animatedBullet);\n\n                //Set the bullets verticle and horizontal velocity.\n                bullet->SetVerticalVelocity(x);\n                bullet->SetHorizontalVelocity(y);\n\n                bullet->Process(0);\n                //Add the new bullet to the bullet container.\n                bullets.push_back(bullet);\n\n                soundSystem->playSound(stunSound, 0, false, &channel0);\n                if (!cheats)\n                    playerShip->setBulletCount(playerShip->getBulletCount() - 1);\n                else\n                {\n                    playerShip->setBulletCount(1337);\n                }\n            }\n        }\n}\n//Timer\nvoid\nGame::GameTimer(float deltaTime)\n{\n    this->m_second;\n    this->m_minute;\n\n    if (m_second < 60)\n    {\n        m_second += deltaTime;\n    }\n    else\n    {\n        m_minute++;\n        m_second = 0;\n    }\n\n    //Covert time (float) to int, then int to to const char* \n    //secs\n    int tmpSec = (int)m_second;\n    sec = std::to_string(tmpSec);\n    currentSecond = sec.c_str();\n    //mins\n    int tmpMin = (int)m_minute;\n    min = std::to_string(tmpMin);\n    currentMinute = min.c_str();\n}\nvoid\nGame::ResetTimer()\n{\n    this->m_second = 0;\n    this->m_minute = 0;\n}\n\n//Creates objects of different sizes and adds them to staticObjects container\nvoid\nGame::SpawnMapBlock(Texture* texture, b2World* world, bool drawSprite, int width, int height, float xPos, float yPos)\n{\n\n    staticObject = new StaticObject(world, blockSprite, drawSprite, width, height, xPos, yPos);\n    staticObject->Process(0);\n    staticObjects.push_back(staticObject);\n}\n//Creates enemies and adds them to enemies container\nvoid\nGame::SpawnEnemy(Texture* texture, b2World* world, float xPos, float yPos)\n{\n    enemySprite = m_pBackBuffer->CreateSprite(texture);\n    animatedSprite = m_pBackBuffer->CreateAnimatedSprite(enemyChaseTexture);\n    enemyObject = new Enemy(world, soundSystem,hitEnemy, spotEnemy, enemySprite, animatedSprite, xPos, yPos, playerShip);\n    enemies.push_back(enemyObject);\n}\n\n//Check if player has won - if player reaches end of map.\nvoid\nGame::CheckPlayerWin()\n{\n    if (playerShip->GetPositionX() >= 700 && !gameFinished)\n    {\n        PlayerWins();\n        LogManager::GetInstance().Log(\"You Win.\");\n    }\n}\n\n//Kills all enemies, plays win music, and stops game loop////\nvoid \nGame::PlayerWins()\n{\n    for (Enemy* enemy : enemies)\n            enemy->killEnemy();\n        backgroundMusic->release();\n        backgroundMusicReleased = true;\n        soundSystem->playSound(winSound, 0, true, &channel0);\n        channel0->setVolume(0.5f);\n        channel0->setPaused(false);\n\n        if (m_second < 15 && m_minute < 1)\n            playerShip->UpdateScore(-50);\n        else if (m_second < 30 && m_minute < 1)\n            playerShip->UpdateScore(-40);\n        else if (m_second < 30 && m_minute < 1)\n            playerShip->UpdateScore(-40);\n        else if (m_second < 45 && m_minute < 1)\n            playerShip->UpdateScore(-30);\n        else if (m_second < 60 && m_minute < 1)\n            playerShip->UpdateScore(-25);\n        else\n            playerShip->UpdateScore(-10);\n\n        gameFinished = true;\n        PauseGame();\n}\n//Pause Simulation///////////////////////////////\nvoid\nGame::PauseGame()\n{\n    //boolean used to switch\n    if (!gamePaused)\n    {\n        gamePaused = true;\n        controllerMode = MENU;\n    }\n    else\n    {\n        gamePaused = false;\n        m_menu->ResetMenu();\n        controllerMode = INGAME;\n    }   \n}\n/////////////////////////Menu//////////////////////////////////////////\nvoid\nGame::ScrollMenu(int x)\n{\n    if (gamePaused){\n        m_menu->ChangeButton(x);\n        soundSystem->playSound(menuButtonSound, 0, false, &channel0);\n    }\n}\nvoid\nGame::PressMenuButton()\n{\n    if (gamePaused)\n    {\n        if (m_menu->getButton() == 0)\n            PauseGame();\n        else if (m_menu->getButton() == 1)\n            ResetGame();\n        else if (m_menu->getButton() == 2)\n            Quit();\n    }\n}\nvoid\nGame::ResetGame()\n{\n    resetGame = true;\n}\nbool\nGame::WillReset()\n{\n    return resetGame;\n}\nControllerOption\nGame::getCurrentController()\n{\n    return controllerMode;\n}\nbool\nGame::isGameFinished()\n{\n    return gameFinished;\n}\nvoid\nGame::enableCheats()\n{\n    if (cheats)\n    {\n        cheats = false;\n        LogManager::GetInstance().Log(\"Cheats Disabled.\");\n    }\n    else\n    {\n        cheats = true;\n        LogManager::GetInstance().Log(\"Cheats Enabled.\");\n        playerShip->setBulletCount(1337);\n    }\n\n}\nbool\nGame::cheatsEnabled()\n{\n    return cheats;\n}\n///////////////Cheats///////////////////////\n//No clip\nvoid \nGame::NoClip()\n{\n    if (!gamePaused)\n    {\n        playerShip->NoClip();\n    }\n}\n//Instantly Win\nvoid\nGame::InstantWin()\n{\n    if (!gamePaused)\n    {\n        LogManager::GetInstance().Log(\"You Win - Cheater.\");\n        PlayerWins();\n    }\n}\n//Kill all enemies\nvoid\nGame::KillAllEnemies()\n{\n    if (!gamePaused)\n    {\n        for (Enemy* enemy : enemies)\n            enemy->killEnemy();\n        LogManager::GetInstance().Log(\"All enemies killed.\");\n    }\n\n}\n//Invincible/God mode - Cannot be caught by enemies\nvoid\nGame::Invincible()\n{\n    if (!gamePaused)\n        playerShip->ToggleInvincible();\n}",
            "title": "Warehouse Escape"
        },
        {
            "location": "/projects/warehouse/#projects",
            "text": "",
            "title": "Projects"
        },
        {
            "location": "/projects/warehouse/#warehouse-escape-solo-project",
            "text": "",
            "title": "Warehouse Escape (Solo Project)"
        },
        {
            "location": "/projects/warehouse/#overview",
            "text": "Warehouse escape is a top-down 2D shooter/strategy game built on COMP710 GP 2D Framework (Game framework created by Steffan Hooper), coded in C++ .\nYou are a cardboard box filled with goods stuck in warehouse. It is your goal to escape by making your way through \nthe warehouse without being caught and jump into the back of the delivery truck to get out of there!  The enemy employees will attempt to catch you, if you are within their range. They will move quickly. If they collide \nwith you then you will be reset. You also have the option kill the enemies by throwing smaller boxes at them, but \nare limited to amount of ammo. If an employee is to catch you, you will respawn back at the start after 5 seconds.  Every escape attempt will be recorded.   The quicker the player reaches the end; the more points they will be rewarded.   To see more, view the Game Design Document & Techinical Design Document, below in the files section.",
            "title": "Overview"
        },
        {
            "location": "/projects/warehouse/#middleware",
            "text": "The middlewares' implemented. Click each to see website(Opens in new tab).  Box2D  SDL  FMOD",
            "title": "Middleware"
        },
        {
            "location": "/projects/warehouse/#controls",
            "text": "",
            "title": "Controls"
        },
        {
            "location": "/projects/warehouse/#screenshots",
            "text": "",
            "title": "Screenshots"
        },
        {
            "location": "/projects/warehouse/#reflection",
            "text": "Overview: \nThis project has been a great learning experience for myself. At first I found it very overwhelming, due to have doing majority \nof my programming in Java.   This project has been a massive learning curve for myself. Throughout the development of \nWarehouse Escape, I utilised the lecture slides, google, and the discussion forum to solve any programming issues that arose. \nDuring development I was fortunate enough to have my flatmate\u2019s test my game as it was being developed. This was very useful for \nfinding bugs, and also great for getting general feedback.   I feel good with the end result. I do however regret not making a more fun side-scroller, rather than the top-down game that it \nis. The game has no memory leaks, bugs, crashes, warnings, and can be restarted, paused, and quit. The quality of the code \ncould be improved, however due to time constraints, I felt the extra time I had would be better adding more features, and making \na gold build because it ran fine. The goal of the game is still the same as mentioned in the design phase. However, some features \nwere change during development, and some were not included.  Challenges: \nBox2D collision offsets - One issue I ran into was the Box2D colliders not being at the same location as my sprites. This was because\nthe sprites were being placed from the middle, and my colliders were not. I solved this by applying the same logic using to place the\nsprites from the middle to the colliders.   Drawing text to the screen caused me a bit of trouble, and was not drawing. I solved this by using the discussion forum provided by my \nlecturer, Steffan Hooper, as other students were having similar problems.   Another challenge I faced was collision filtering. I knew what logic I wanted my game to apply, but I needed to use Box2D's filtering\nsystem to solve this challenge. I spent some time researching; reading through the Box2D manual, and viewing other's problems on the \ninternet. Then I was able to apply what I had read into my game. Having collision filtering was essential to this game because I wanted\ndifferent entities to interact differently with each other, in terms of collision.  What I would do different next time: \nIn future projects, I would like to create a resource manager. This way all assets needed will be loaded into the game on launch, then can be\naccessed by all classes until the game is closed. Additionally, in future projects, I will be making more time to make games more data driven.  I would like to upskill more before taking on projects in the future, as I did not upskill enough before using Box2D. This resulted\nin me using development time to upskill.  Adding keyboard and mouse support for future games will definitely be implemented.",
            "title": "Reflection"
        },
        {
            "location": "/projects/warehouse/#files",
            "text": "Game Design Document  Techinical Design Document  Reflection",
            "title": "Files"
        },
        {
            "location": "/projects/warehouse/#references",
            "text": "Catto, E. (2015). Box2D | A 2D Physics Engine for Games. [online] Box2d.org.  \nAvailable at: http://box2d.org/ [Accessed 23 Oct. 2016].  Fmod.org. (2016). FMOD. [online]  \nAvailable at: http://www.fmod.org/ [Accessed 23 Oct. 2016].  YouTube. (2016). NoCopyrightSounds. [online]  \nAvailable at: https://www.youtube.com/user/NoCopyrightSounds [Accessed 23 Oct. 2016].  OpenGameArt.org. (2016). OpenGameArt.org. [online]  \nAvailable at: http://opengameart.org/ [Accessed 23 Oct. 2016].  Libsdl.org. (2016). Simple DirectMedia Layer - Homepage. [online]  \nAvailable at: https://www.libsdl.org/ [Accessed 23 Oct. 2016].",
            "title": "References"
        },
        {
            "location": "/projects/warehouse/#code-snippet",
            "text": "// COMP710 GP 2D Framework\n\n// This includes:\n#include \"game.h\"\n\n// Local includes:\n#include \"backbuffer.h\"\n#include \"inputhandler.h\"\n#include \"logmanager.h\"\n#include \"Texture.h\"\n#include \"sprite.h\"\n#include \"AnimatedSprite.h\"\n#include \"entity.h\"\n#include \"PlayerShip.h\"\n#include \"Enemy.h\"\n#include \"Bullet.h\"\n#include \"background.h\"\n#include \"Box2D.h\"\n#include \"staticObject.h\"\n#include \"Menu.h\"\n\n// Library includes:\n#include <cassert>\n#include <SDL.h>\n#include <SDL_ttf.h>\n\n// Static Members:\nGame* Game::sm_pInstance = 0;\n\nGame&\nGame::GetInstance()\n{\n    if (sm_pInstance == 0)\n    { \n        sm_pInstance = new Game();\n    }\n\n    assert(sm_pInstance);\n\n    return (*sm_pInstance);\n}\n\nvoid \nGame::DestroyInstance()\n{\n    delete sm_pInstance; \n    sm_pInstance = 0;\n\n}\n\nGame::Game()\n: m_pBackBuffer(0)\n, m_pInputHandler(0)\n, m_looping(true)\n, m_executionTime(0)\n, m_elapsedSeconds(0)\n, m_frameCount(0)\n, m_FPS(0)\n, m_numUpdates(0)\n, m_lastTime(0)\n, m_lag(0)\n{\n\n}\n\nGame::~Game()\n{\n    //delete entities\n    for (auto i = bullets.begin(); i != bullets.end(); ++i)\n        delete *i;\n\n    for (auto x = enemies.begin(); x != enemies.end(); ++x)\n        delete *x;\n\n    for (auto y = staticObjects.begin(); y != staticObjects.end(); y++)\n        delete *y;\n\n    animatedBullet->~AnimatedSprite();\n    enemyChaseTexture->~Texture();\n\n    //release audio\n    if (!backgroundMusicReleased)\n        backgroundMusic->release();\n    winSound->release();\n    stunSound->release();\n    menuButtonSound->release();\n    hitEnemy->release();\n    spotEnemy->release();\n    hitWall->release();\n\n    //Background/Map\n\n\n    //other\n    delete m_pInputHandler;\n    m_pInputHandler = 0;    \n\n    delete world;\n    world = 0;\n\n    delete m_pBackBuffer;\n    m_pBackBuffer = 0;\n\n    //Delete sprites\n    delete mapSprite;\n    mapSprite = 0;\n\n    delete background;\n    background = 0;\n\n    delete playerSprite;\n    playerSprite = 0;\n\n    delete playerShip;\n    playerShip = 0;\n\n    delete startScreen;\n    startScreen = 0;\n\n    delete animatedBullet;\n    animatedBullet = 0;\n\n    delete blockSprite;\n    blockSprite = 0;\n\n    //MENU\n    delete m_menu;\n    m_menu = 0;\n\n    soundSystem->release();\n}\n\nbool \nGame::Initialise()\n{\n    m_pBackBuffer = new BackBuffer();\n    if (!m_pBackBuffer->Initialise(SCREEN_WIDTH, SCREEN_HEIGHT))\n    {\n        LogManager::GetInstance().Log(\"BackBuffer Init Fail!\");\n        return (false);\n    }\n\n    m_pInputHandler = new InputHandler();\n    if (!m_pInputHandler->Initialise())\n    {\n        LogManager::GetInstance().Log(\"InputHandler Init Fail!\");\n        return (false);\n    }\n\n    controllerMode = STARTSCREEN;\n\n    //MENU\n    m_menu = new Menu();\n    m_menu->Initialise(m_pBackBuffer, SCREEN_WIDTH, SCREEN_HEIGHT);\n\n    //SOUND\n    // Create the sound system object.\n    FMOD::System_Create(&soundSystem);\n    // Initialize the sound system object.\n    soundSystem->init(512, FMOD_INIT_NORMAL, 0);\n\n    //Initialize background music, and play.\n    soundSystem->createSound(\"assets\\\\sounds\\\\btfragout.mp3\", FMOD_DEFAULT, 0, &backgroundMusic);\n    backgroundMusic->setMode(FMOD_LOOP_NORMAL);\n    soundSystem->playSound(backgroundMusic, 0, true, &channel0);\n    channel0->setVolume(0.1f);\n    channel0->setPaused(false);\n\n    //Initialize other sounds\n    soundSystem->createSound(\"assets\\\\sounds\\\\shoot01.flac\", FMOD_DEFAULT, 0, &stunSound);\n    stunSound->setMode(FMOD_LOOP_OFF);\n    soundSystem->createSound(\"assets\\\\sounds\\\\hitWall.flac\", FMOD_DEFAULT, 0, &hitWall);\n    hitWall->setMode(FMOD_LOOP_OFF);\n    soundSystem->createSound(\"assets\\\\sounds\\\\wincloud9.mp3\", FMOD_DEFAULT, 0, &winSound);\n    winSound->setMode(FMOD_LOOP_OFF);\n    soundSystem->createSound(\"assets\\\\sounds\\\\menuSelection.wav\", FMOD_DEFAULT, 0, &menuButtonSound);\n    menuButtonSound->setMode(FMOD_LOOP_OFF);\n\n    //START SCREEN\n    startScreen = m_pBackBuffer->CreateSprite(\"assets\\\\sprites\\\\playScreen2.png\");\n    startScreen->SetX(SCREEN_WIDTH/2);\n    startScreen->SetY(SCREEN_HEIGHT/2);\n\n    //MAP\n    //Load wall sprite\n    wallTexture = m_pBackBuffer->CreateTexture(\"assets\\\\sprites\\\\blackWall01.png\");\n    blockSprite = m_pBackBuffer->CreateSprite(wallTexture);\n\n    //Spawn outer walls\n    SpawnMapBlock(wallTexture,world,true,800, 10, SCREEN_WIDTH/2, SCREEN_HEIGHT-5);\n    SpawnMapBlock(wallTexture, world, true, 800, 10, SCREEN_WIDTH / 2, 5);\n    SpawnMapBlock(wallTexture, world, true, 10, 600, SCREEN_WIDTH - 5, SCREEN_HEIGHT / 2);\n    SpawnMapBlock(wallTexture, world, true, 10, 600, 5, SCREEN_HEIGHT / 2);\n    //spawn inner walls (Truck Wall)\n    SpawnMapBlock(wallTexture, world, true, 10, 510, SCREEN_WIDTH - 137, SCREEN_HEIGHT / 2 - 36);\n    SpawnMapBlock(wallTexture, world, true, 10, 30, SCREEN_WIDTH - 137, SCREEN_HEIGHT / 2 + 275);\n    //spawn inner walls\n    SpawnMapBlock(wallTexture, world, false,20, 500, 100, SCREEN_HEIGHT / 2 + 50);\n    SpawnMapBlock(wallTexture, world, false, 400, 30, 380, 115);\n    SpawnMapBlock(wallTexture, world, false, 400, 60, 380, 215);\n    SpawnMapBlock(wallTexture, world, false, 30, 200, 195, 415);\n    SpawnMapBlock(wallTexture, world, false, 30, 200, 295, 415);\n    SpawnMapBlock(wallTexture, world, false, 400, 30, 380, 415);\n    SpawnMapBlock(wallTexture, world, false, 150, 30, 460, 330);\n    SpawnMapBlock(wallTexture, world, false, 150, 30, 460, 500);\n\n    //Initialize s\n    mapSprite = m_pBackBuffer->CreateSprite(\"assets\\\\sprites\\\\background2.png\");\n    background = new Background(0, 0);\n    background->Initialise(mapSprite);\n\n    //PLAYER\n    //Load the player sprite.\n    playerSprite = m_pBackBuffer->CreateSprite(\"assets\\\\sprites\\\\playerBox.png\");\n    //Create the player instance.\n    playerShip = new PlayerShip(world, 50, 550);\n    playerShip->Initialise(playerSprite);\n\n    //BULLET\n    animatedBullet = m_pBackBuffer->CreateAnimatedSprite(\"assets\\\\sprites\\\\cardboardBullet02.png\");\n\n    //ENEMIES\n    //load enemy sprite\n    enemyTexture = m_pBackBuffer->CreateTexture(\"assets\\\\sprites\\\\enemyIdle.png\");\n    enemyChaseTexture = m_pBackBuffer->CreateTexture(\"assets\\\\sprites\\\\enemyChase.png\");\n    soundSystem->createSound(\"assets\\\\sounds\\\\hitEnemy.flac\", FMOD_DEFAULT, 0, &hitEnemy);\n    soundSystem->createSound(\"assets\\\\sounds\\\\huh.wav\", FMOD_DEFAULT, 0, &spotEnemy);\n\n    //spawn enemies..\n    SpawnEnemy(enemyTexture, world, 300, 50);\n    SpawnEnemy(enemyTexture, world, 300, 280);\n    SpawnEnemy(enemyTexture, world, 300, 150);\n    SpawnEnemy(enemyTexture, world, 450, 280);\n    SpawnEnemy(enemyTexture, world, 300, 575);\n\n    //Set Timer to default values\n    ResetTimer();\n\n    m_lastTime = SDL_GetTicks();\n    m_lag = 0.0f;\n    return (true);\n}\n\nbool \nGame::DoGameLoop()\n{\n    const float stepSize = 1.0f / 60.0f;\n    assert(m_pInputHandler);\n    m_pInputHandler->ProcessInput(*this);\n\n    if (m_looping)\n    {\n        int current = SDL_GetTicks();\n        float deltaTime = (current - m_lastTime) / 1000.0f;\n        m_lastTime = current;\n        m_executionTime += deltaTime;\n        m_lag += deltaTime;\n        while (m_lag >= stepSize)\n        {\n            //If game is not paused then process as normal\n            if (!gamePaused && !inStartScreen)\n            {\n                world->Step(stepSize, 6, 6);\n                Process(stepSize);\n            }\n            //if game is paused freeze simulation   \n            else\n            {\n                Process(0);\n                world->Step(0, 0, 0);\n            }       \n            m_lag -= stepSize;\n            ++m_numUpdates;\n        }\n        Draw(*m_pBackBuffer);\n    }\n\n    //If the game is paused, then pause all audio\n    if (!gamePaused)\n        soundSystem->update();\n\n    SDL_Delay(1);\n    return (m_looping);\n}\n\nvoid \nGame::Process(float deltaTime)\n{\n        // Count total simulation time elapsed:\n        m_elapsedSeconds += deltaTime;\n\n        // Frame Counter\n        if (m_elapsedSeconds > 1)\n        {\n            m_elapsedSeconds -= 1;\n            m_FPS = m_frameCount;\n            m_frameCount = 0;\n        }\n        //has player won?\n        CheckPlayerWin();\n\n        //if game is not finished, then process.\n        if (!gameFinished)\n        {\n            // W02.3: Process each bullet in the container.\n            for (Bullet* currentBullet : bullets)\n            {\n                if (currentBullet->IsDead() == false)\n                    currentBullet->Process(deltaTime);\n            }\n\n            //process each enemy in container\n            for (Enemy* enemy : enemies)\n            if (enemy->IsDead() == false)\n                enemy->Process(deltaTime);\n\n            GameTimer(deltaTime);\n        }\n\n        playerShip->Process(deltaTime);\n\n        //Remove any dead bullets from the container...\n        std::vector<Bullet*>::iterator bulletIter;\n        bulletIter = bullets.begin();\n        while (bulletIter != bullets.end())\n        {\n            Bullet* currentBullet = *bulletIter;\n            if (currentBullet->IsDead())\n            {\n                bulletIter = bullets.erase(bulletIter);\n                delete currentBullet;\n            }\n            else\n                ++bulletIter;\n        }\n\n        bullets.shrink_to_fit();\n\n        //Remove dead enemies from container\n        std::vector<Enemy*>::iterator enemyIter;\n        enemyIter = enemies.begin();\n        while (enemyIter != enemies.end())\n        {\n            Enemy* currentEnemy = *enemyIter;\n            if (currentEnemy->IsDead())\n            {\n                enemyIter = enemies.erase(enemyIter);\n                delete currentEnemy;\n            }\n            else\n                ++enemyIter;\n        }\n        enemies.shrink_to_fit();\n}\n\nvoid \nGame::Draw(BackBuffer& backBuffer)\n{\n    ++m_frameCount;\n    backBuffer.Clear();\n\n    //Draw background\n    background->Draw(backBuffer);\n\n    //draw static objects\n    for (StaticObject* obj : staticObjects)\n        if (obj->draw == true)\n            obj->Draw(backBuffer);\n\n    //Draw start screen\n    if (inStartScreen)\n        startScreen->Draw(backBuffer);\n    else\n    {\n        //draw enemies\n        for (Enemy* enemy : enemies)\n            enemy->Draw(backBuffer);\n\n        // W02.3: Draw all bullets in container...\n        for (Bullet* currentBullet : bullets)\n            currentBullet->Draw(backBuffer);\n\n        //Draw the player...\n        playerShip->Draw(backBuffer);\n\n        if (gamePaused)\n            m_menu->Draw(backBuffer);\n        if (gameFinished)\n        {\n            backBuffer.DrawText(false, \"You win!\", SCREEN_WIDTH / 2 - 90, SCREEN_HEIGHT / 2 - 200);\n        }\n\n        //Draw Attempts by player\n        backBuffer.DrawText(true, \"Attempts:\", 10, 12);\n        backBuffer.DrawText(true, playerShip->getPlayerAttempts(), 110, 14);\n        backBuffer.DrawText(true, \"Ammo:\", 10, 32);\n        backBuffer.DrawText(true, playerShip->printBulletNumber(), 110, 32);\n\n        //Score\n        backBuffer.DrawText(true, playerShip->getPlayerScore(), 675, 76);\n\n        //Draw Timer\n        backBuffer.DrawText(true, \"Time:\", 700, 12);\n        backBuffer.DrawText(true, \"_____\", 700, 12);\n        backBuffer.DrawText(true, \"Min:\", 675, 36);\n        backBuffer.DrawText(true, this->currentMinute, 745, 36);\n        backBuffer.DrawText(true, \"Sec:\", 675, 56);\n        backBuffer.DrawText(true, this->currentSecond, 745, 56);\n    }\n\n    backBuffer.Present();   \n}\n\nvoid \nGame::Quit()\n{\n    m_looping = false;\n}\nvoid\nGame::StartGame()\n{       \n    inStartScreen = false;\n    controllerMode = INGAME;\n}\n\n//Player directionals\n//Move player horizontally \nvoid \nGame::MovePlayerLeft(int input)\n{\n    playerShip->setXInput((float)input);\n}\n//move player vertically\nvoid\nGame::MovePlayerUp(int input)\n{\n    playerShip->setYInput((float)input);\n}\n\n//Spawn bullet\nvoid \nGame::FireStun(float x, float y)\n{\n        //if game is not finished\n        if (!gameFinished)\n        {\n            if (playerShip->getBulletCount() > 0)\n            {   \n                //Create a new bullet object.\n                bullet = new Bullet(world, soundSystem, hitWall, playerShip->GetPositionX(), playerShip->GetPositionY());\n                bullet->Initialise(animatedBullet);\n\n                //Set the bullets verticle and horizontal velocity.\n                bullet->SetVerticalVelocity(x);\n                bullet->SetHorizontalVelocity(y);\n\n                bullet->Process(0);\n                //Add the new bullet to the bullet container.\n                bullets.push_back(bullet);\n\n                soundSystem->playSound(stunSound, 0, false, &channel0);\n                if (!cheats)\n                    playerShip->setBulletCount(playerShip->getBulletCount() - 1);\n                else\n                {\n                    playerShip->setBulletCount(1337);\n                }\n            }\n        }\n}\n//Timer\nvoid\nGame::GameTimer(float deltaTime)\n{\n    this->m_second;\n    this->m_minute;\n\n    if (m_second < 60)\n    {\n        m_second += deltaTime;\n    }\n    else\n    {\n        m_minute++;\n        m_second = 0;\n    }\n\n    //Covert time (float) to int, then int to to const char* \n    //secs\n    int tmpSec = (int)m_second;\n    sec = std::to_string(tmpSec);\n    currentSecond = sec.c_str();\n    //mins\n    int tmpMin = (int)m_minute;\n    min = std::to_string(tmpMin);\n    currentMinute = min.c_str();\n}\nvoid\nGame::ResetTimer()\n{\n    this->m_second = 0;\n    this->m_minute = 0;\n}\n\n//Creates objects of different sizes and adds them to staticObjects container\nvoid\nGame::SpawnMapBlock(Texture* texture, b2World* world, bool drawSprite, int width, int height, float xPos, float yPos)\n{\n\n    staticObject = new StaticObject(world, blockSprite, drawSprite, width, height, xPos, yPos);\n    staticObject->Process(0);\n    staticObjects.push_back(staticObject);\n}\n//Creates enemies and adds them to enemies container\nvoid\nGame::SpawnEnemy(Texture* texture, b2World* world, float xPos, float yPos)\n{\n    enemySprite = m_pBackBuffer->CreateSprite(texture);\n    animatedSprite = m_pBackBuffer->CreateAnimatedSprite(enemyChaseTexture);\n    enemyObject = new Enemy(world, soundSystem,hitEnemy, spotEnemy, enemySprite, animatedSprite, xPos, yPos, playerShip);\n    enemies.push_back(enemyObject);\n}\n\n//Check if player has won - if player reaches end of map.\nvoid\nGame::CheckPlayerWin()\n{\n    if (playerShip->GetPositionX() >= 700 && !gameFinished)\n    {\n        PlayerWins();\n        LogManager::GetInstance().Log(\"You Win.\");\n    }\n}\n\n//Kills all enemies, plays win music, and stops game loop////\nvoid \nGame::PlayerWins()\n{\n    for (Enemy* enemy : enemies)\n            enemy->killEnemy();\n        backgroundMusic->release();\n        backgroundMusicReleased = true;\n        soundSystem->playSound(winSound, 0, true, &channel0);\n        channel0->setVolume(0.5f);\n        channel0->setPaused(false);\n\n        if (m_second < 15 && m_minute < 1)\n            playerShip->UpdateScore(-50);\n        else if (m_second < 30 && m_minute < 1)\n            playerShip->UpdateScore(-40);\n        else if (m_second < 30 && m_minute < 1)\n            playerShip->UpdateScore(-40);\n        else if (m_second < 45 && m_minute < 1)\n            playerShip->UpdateScore(-30);\n        else if (m_second < 60 && m_minute < 1)\n            playerShip->UpdateScore(-25);\n        else\n            playerShip->UpdateScore(-10);\n\n        gameFinished = true;\n        PauseGame();\n}\n//Pause Simulation///////////////////////////////\nvoid\nGame::PauseGame()\n{\n    //boolean used to switch\n    if (!gamePaused)\n    {\n        gamePaused = true;\n        controllerMode = MENU;\n    }\n    else\n    {\n        gamePaused = false;\n        m_menu->ResetMenu();\n        controllerMode = INGAME;\n    }   \n}\n/////////////////////////Menu//////////////////////////////////////////\nvoid\nGame::ScrollMenu(int x)\n{\n    if (gamePaused){\n        m_menu->ChangeButton(x);\n        soundSystem->playSound(menuButtonSound, 0, false, &channel0);\n    }\n}\nvoid\nGame::PressMenuButton()\n{\n    if (gamePaused)\n    {\n        if (m_menu->getButton() == 0)\n            PauseGame();\n        else if (m_menu->getButton() == 1)\n            ResetGame();\n        else if (m_menu->getButton() == 2)\n            Quit();\n    }\n}\nvoid\nGame::ResetGame()\n{\n    resetGame = true;\n}\nbool\nGame::WillReset()\n{\n    return resetGame;\n}\nControllerOption\nGame::getCurrentController()\n{\n    return controllerMode;\n}\nbool\nGame::isGameFinished()\n{\n    return gameFinished;\n}\nvoid\nGame::enableCheats()\n{\n    if (cheats)\n    {\n        cheats = false;\n        LogManager::GetInstance().Log(\"Cheats Disabled.\");\n    }\n    else\n    {\n        cheats = true;\n        LogManager::GetInstance().Log(\"Cheats Enabled.\");\n        playerShip->setBulletCount(1337);\n    }\n\n}\nbool\nGame::cheatsEnabled()\n{\n    return cheats;\n}\n///////////////Cheats///////////////////////\n//No clip\nvoid \nGame::NoClip()\n{\n    if (!gamePaused)\n    {\n        playerShip->NoClip();\n    }\n}\n//Instantly Win\nvoid\nGame::InstantWin()\n{\n    if (!gamePaused)\n    {\n        LogManager::GetInstance().Log(\"You Win - Cheater.\");\n        PlayerWins();\n    }\n}\n//Kill all enemies\nvoid\nGame::KillAllEnemies()\n{\n    if (!gamePaused)\n    {\n        for (Enemy* enemy : enemies)\n            enemy->killEnemy();\n        LogManager::GetInstance().Log(\"All enemies killed.\");\n    }\n\n}\n//Invincible/God mode - Cannot be caught by enemies\nvoid\nGame::Invincible()\n{\n    if (!gamePaused)\n        playerShip->ToggleInvincible();\n}",
            "title": "Code Snippet"
        },
        {
            "location": "/projects/shamballs/",
            "text": "Projects\n\n\n\n\nShamballs (Team Project)\n\n\nOverview\n\n\nShamballs is a 3D, competitive, third person, multiplayer game aimed ages 5+. It has three\ndifferent game modes. First is time trial mode, this is where a player can attempt to race through a\nlevel to get the best possible time. Secondly is race, where players race against each other on\npremade levels to finish first. The levels are created in a point to point format, there is one start\npoint and one finish point. The second game mode is derby; this is where players will try to push\nopponents off a premade arena to be the last man standing.\n\n\nA level editor is available to create levels for each game mode. This will provide a quick\nand easy way of creating fun interactive levels.\n\n\n\n\n\nTo see more, view the Game Design Document & Techinical Design Document, below in the files section.\n\n\n\n\nTeam & Work Contributions\n\n\nSean Chambers\n: smchambers95@gmail.com\n\nTook care of the characteristic features in the development of Shamballs. Features that gave the\ngame feel, goals and characteristics. \n\n\nContributions:\n\nResourceManager\n\n\nCo-created Menu\n\n\nPickups\n\n\nPlayerStart\n\n\nPlayerFinish\n\n\nGame overlays e.g. pickup icons, timers \n\n\nAdded & created sounds\n\n\nMemory Management\n\n\nMarc Tucker\n: marcedforlife@gmail.com\n\nMarc lead as the primary developer on this project. He built majority of the framework. \nHe was able assist the team with any issues they ran into. His motivation kept this \nproject moving rapidly.\n\n\nContributions:\n\nEditor\n\n\nEngine\n\n\nCamera\n\n\nEntity\n\n\nInputManager\n\n\nLevel\n\n\nLevelManager\n\n\nMenuManager\n\n\nPlayer\n\n\nWorldBlock\n\n\nMemory Management\n\n\nMathew Bielby\n: mathewbielby3@gmail.com\n\nMathew's primary role in the project was implementing multiplayer. He also provided\ninsightful feedback during the development. \n\n\nContributions:\n\nCamera\n\nEngine\n\nMenuManager\n\nMultiplayerManager\n\nShamballs Dedicated\n\n\n\n\nMiddleware\n\n\nThe middlewares' implemented. Click each to see website(Opens in new tab).\n\n\nDirectX v11.1\n\n\nDirectX Tool Kit v2016.9.15.1\n \n\nPhysX v3.3.3\n \n\nRaknet v4.081\n \n \n\nFMOD\n\n\n\n\n\nScreenshots\n\n\n\n\n \n\n\n\n\nReflection\n\n\nOverview:\n\nWhen I initially started this project, I was quite concerned with how I would perform in my team, as they grasp new concepts\nquicker than I do. Choosing to build a game using different middleware (DirectX & PhysX) than before meant that we all had to learn \nit, and implement it. This took up a lot of development time. However, once we had it all up and running, we were able to progress \nvery quickly. Throughout the development I asked for feedback on the algorithms I wrote. As my peers are more experienced in \nprogramming, having their feedback ensured that the outcome I produced satisfied the whole team. \n\n\nAs I felt as though I may not be able to contribute as much as my team members could, I took it upon myself to be responsibile \nfor the documentation. Once in development, I handled most of the visual overlay text, icons, and sounds and how these were \npresented (e.g. current pickup, connection status). Tackling these tasks allowed for the other team members to focus down on \nmore advanced sections of the game. As I did not generally code the more advanced code, I did peer program with them. This \nwas done via Skype, and in person. This peer programming proved useful as, I am able to understand the code written, and \nwhy it was written in such way.\n\n\nOverall, the project was extremely exciting, fun, and challenging. We could have built another 2D game using middleware that we\nare familiar with, and finished it with ease. Taking the approach we did (3D game with different middleware), I have now got to\nlearn and experience a whole new area of game development, using middleware Triple A games use. \n\n\nChallenges:\n\nCollision filtering was a task set to me. When i began this task, I understood the concept of collision filtering, and thought it\nwould be very simple. I tried implementing this many times, but did not understand enough to get it working, even after reading the \ndocumentation, and sample code. I tried searching for others' examples on the web, but was not able to find any. This problem was \neventually solved, when I sat down with my team member Marc, and then ran through it together. We got it implemented. I was then able\nto carry on working with my pickups logic. \nThis challenge was very frustrating because I felt that it was not documented well enough. However, due to having very capable team\nmates, it was resolved. \n\n\nPlacing text, and icons on the screen was a bit of a challenge. The coordinate system is different to what I previously worked on. 0,0 was\nin the middle of the window. This challenged was overcome by using my brain, alongside using trial and error.\n\n\nAs a student, I(And my team) had to be focused on another three papers during the course of this development. Getting a solid amount of \ntime on the project in one go was always difficult to find. However, we managed, and built a really fun game. \n\n\nWhat I would do different next time:\n\nIf I take on a project like this again, I would need to upskill more in vector math, quaternions and matricies. I would almost double the\nestimated time it's going to take to build and limit the scope to fit, to ensure that the whole project in fully completed.\n\n\nTo see full reflection, see Reflection in the files section.\n\n\n\n\nPersonal Log\n\n\nDevelopment Log\n\n\n\n\nFiles\n\n\nGame Design Document\n\n\nTechinical Design Document\n\n\n\n\nReferences\n\n\nAudacityteam.org. (2016). Audacity\u00ae.\n \nAvailable at: http://www.audacityteam.org/\n\n\nFmod.org. (2016). FMOD.\n\nAvailable at: http://www.fmod.org/\n\n\nGitHub. (2016). Microsoft/DirectXTK.\n\nAvailable at: https://github.com/Microsoft/DirectXTK/\n\n\nDocs.nvidia.com. (2016). NVIDIA\u00ae PhysX\u00ae SDK 3.3.4 Documentation \u2014 NVIDIA PhysX SDK 3.3.4 Documentation.\nAvailable at:\n http://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Index.html\n\n\nJenkinssoftware.com. (2016). RakNet - Multiplayer game network engine.\n\nAvailable at: http://www.jenkinssoftware.com/\n\n\n\n\nCode Snippet\n\n\nResource Manager:\n\n\n#include \"pch.h\"\n\n#include \"ResourceManager.h\"\n#include \"Engine.h\"\n\nResourceManager::ResourceManager()\n{\n    Initialize();\n}\n\nResourceManager::~ResourceManager()\n{\n    //Delete all sounds from m_SoundList\n    std::map<SoundName::SoundName, Sound*>::iterator itr = m_SoundMap.begin();\n    while (itr != m_SoundMap.end()){\n        itr->second->release();\n        ++itr;\n    }\n    m_SoundMap.clear();\n\n    //Delete textures\n    std::map<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>::iterator titr = m_TextureMap.begin();\n    while (titr != m_TextureMap.end()){\n        titr->second->Get()->Release();\n        ++titr;\n    }\n    m_TextureMap.clear();\n}\n\nbool ResourceManager::Initialize()\n{\n    //Load sounds, and add to sound map.\n\n    //Countdown\n    Sound* countdown;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\countdown.mp3\", FMOD_DEFAULT, 0, &countdown);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::COUNTDOWN, countdown));\n\n    //Menu\n    Sound* menuclick;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\menuclick.wav\", FMOD_DEFAULT, 0, &menuclick);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::MENUCLICK, menuclick));\n\n    Sound* menuscroll;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\menuscroll.wav\", FMOD_DEFAULT, 0, &menuscroll);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::MENUSCROLL, menuscroll));\n\n    //Player sounds\n    Sound* boostsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\boostsound.wav\", FMOD_DEFAULT, 0, &boostsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::BOOSTSOUND, boostsound));\n\n    Sound* growsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\growsound.mp3\", FMOD_DEFAULT, 0, &growsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::GROWSOUND, growsound));\n\n    Sound* shrinksound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\shrinksound.mp3\", FMOD_DEFAULT, 0, &shrinksound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::SHRINKSOUND, shrinksound));\n\n    Sound* pickupsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\pickupsound.mp3\", FMOD_DEFAULT, 0, &pickupsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::PICKUP, pickupsound));\n\n    Sound* jumpsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\jumpsound.mp3\", FMOD_DEFAULT, 0, &jumpsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::JUMP, jumpsound));\n\n    Sound* landsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\landsound.wav\", FMOD_DEFAULT, 0, &landsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::LAND, landsound));\n\n    Sound* playermovementsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\playermovementsound.wav\", FMOD_DEFAULT, 0, &playermovementsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::PLAYERMOVEMENT, playermovementsound));\n\n    //Background music\n    Sound* backgroundmusic;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\backgroundmusic.mp3\", FMOD_DEFAULT, 0, &backgroundmusic);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::BACKGROUND, backgroundmusic));\n\n    //Load texture, and add to sound map.\n    //Wood texutre\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* woodTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\woodtexture.png\", nullptr, woodTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::WOOD, woodTexture));\n\n    //Concrete texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* concreteTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\concretetexture.png\", nullptr, concreteTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::CONCRETE, concreteTexture));\n\n    //Steel texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* steelTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\steeltexture.png\", nullptr, steelTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::STEEL, steelTexture));\n\n    //Boost texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* pickupTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\pickuptexture.png\", nullptr, pickupTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::PICKUP, pickupTexture));\n\n    //Sky Texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* skyTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\skytexture.png\", nullptr, skyTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::SKY, skyTexture));\n\n    //Finish Texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* finishTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\finish.png\", nullptr, finishTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::FINISH, finishTexture));\n\n    //ICONS\n    //Cursor\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* cursoricon = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\cursor.png\", nullptr, cursoricon->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::CURSOR, cursoricon));\n\n    //Boost Icon Texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* boostIcon = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\boosticon64.png\", nullptr, boostIcon->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::BOOST, boostIcon));\n\n    //Grow Icon Texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* growicon = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\growicon64.png\", nullptr, growicon->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::GROW, growicon));\n\n    //DERBY ICONS\n    //connected icon\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* connected = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\connected.png\", nullptr, connected->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::CONNECTED, connected));\n    //not connected icon\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* notconnected = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\notconnected.png\", nullptr, notconnected->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::NOTCONNECTED, notconnected));\n    //connect button\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* connectbutton = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\connectbutton.png\", nullptr, connectbutton->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::CONNECT, connectbutton));\n\n    return true;\n}",
            "title": "Shamballs"
        },
        {
            "location": "/projects/shamballs/#projects",
            "text": "",
            "title": "Projects"
        },
        {
            "location": "/projects/shamballs/#shamballs-team-project",
            "text": "",
            "title": "Shamballs (Team Project)"
        },
        {
            "location": "/projects/shamballs/#overview",
            "text": "Shamballs is a 3D, competitive, third person, multiplayer game aimed ages 5+. It has three\ndifferent game modes. First is time trial mode, this is where a player can attempt to race through a\nlevel to get the best possible time. Secondly is race, where players race against each other on\npremade levels to finish first. The levels are created in a point to point format, there is one start\npoint and one finish point. The second game mode is derby; this is where players will try to push\nopponents off a premade arena to be the last man standing.  A level editor is available to create levels for each game mode. This will provide a quick\nand easy way of creating fun interactive levels.   To see more, view the Game Design Document & Techinical Design Document, below in the files section.",
            "title": "Overview"
        },
        {
            "location": "/projects/shamballs/#team-work-contributions",
            "text": "Sean Chambers : smchambers95@gmail.com \nTook care of the characteristic features in the development of Shamballs. Features that gave the\ngame feel, goals and characteristics.   Contributions: ResourceManager  Co-created Menu  Pickups  PlayerStart  PlayerFinish  Game overlays e.g. pickup icons, timers   Added & created sounds  Memory Management  Marc Tucker : marcedforlife@gmail.com \nMarc lead as the primary developer on this project. He built majority of the framework. \nHe was able assist the team with any issues they ran into. His motivation kept this \nproject moving rapidly.  Contributions: Editor  Engine  Camera  Entity  InputManager  Level  LevelManager  MenuManager  Player  WorldBlock  Memory Management  Mathew Bielby : mathewbielby3@gmail.com \nMathew's primary role in the project was implementing multiplayer. He also provided\ninsightful feedback during the development.   Contributions: Camera Engine MenuManager MultiplayerManager Shamballs Dedicated",
            "title": "Team &amp; Work Contributions"
        },
        {
            "location": "/projects/shamballs/#middleware",
            "text": "The middlewares' implemented. Click each to see website(Opens in new tab).  DirectX v11.1  DirectX Tool Kit v2016.9.15.1   PhysX v3.3.3   Raknet v4.081     FMOD",
            "title": "Middleware"
        },
        {
            "location": "/projects/shamballs/#screenshots",
            "text": "",
            "title": "Screenshots"
        },
        {
            "location": "/projects/shamballs/#reflection",
            "text": "Overview: \nWhen I initially started this project, I was quite concerned with how I would perform in my team, as they grasp new concepts\nquicker than I do. Choosing to build a game using different middleware (DirectX & PhysX) than before meant that we all had to learn \nit, and implement it. This took up a lot of development time. However, once we had it all up and running, we were able to progress \nvery quickly. Throughout the development I asked for feedback on the algorithms I wrote. As my peers are more experienced in \nprogramming, having their feedback ensured that the outcome I produced satisfied the whole team.   As I felt as though I may not be able to contribute as much as my team members could, I took it upon myself to be responsibile \nfor the documentation. Once in development, I handled most of the visual overlay text, icons, and sounds and how these were \npresented (e.g. current pickup, connection status). Tackling these tasks allowed for the other team members to focus down on \nmore advanced sections of the game. As I did not generally code the more advanced code, I did peer program with them. This \nwas done via Skype, and in person. This peer programming proved useful as, I am able to understand the code written, and \nwhy it was written in such way.  Overall, the project was extremely exciting, fun, and challenging. We could have built another 2D game using middleware that we\nare familiar with, and finished it with ease. Taking the approach we did (3D game with different middleware), I have now got to\nlearn and experience a whole new area of game development, using middleware Triple A games use.   Challenges: \nCollision filtering was a task set to me. When i began this task, I understood the concept of collision filtering, and thought it\nwould be very simple. I tried implementing this many times, but did not understand enough to get it working, even after reading the \ndocumentation, and sample code. I tried searching for others' examples on the web, but was not able to find any. This problem was \neventually solved, when I sat down with my team member Marc, and then ran through it together. We got it implemented. I was then able\nto carry on working with my pickups logic. \nThis challenge was very frustrating because I felt that it was not documented well enough. However, due to having very capable team\nmates, it was resolved.   Placing text, and icons on the screen was a bit of a challenge. The coordinate system is different to what I previously worked on. 0,0 was\nin the middle of the window. This challenged was overcome by using my brain, alongside using trial and error.  As a student, I(And my team) had to be focused on another three papers during the course of this development. Getting a solid amount of \ntime on the project in one go was always difficult to find. However, we managed, and built a really fun game.   What I would do different next time: \nIf I take on a project like this again, I would need to upskill more in vector math, quaternions and matricies. I would almost double the\nestimated time it's going to take to build and limit the scope to fit, to ensure that the whole project in fully completed.  To see full reflection, see Reflection in the files section.",
            "title": "Reflection"
        },
        {
            "location": "/projects/shamballs/#personal-log",
            "text": "Development Log",
            "title": "Personal Log"
        },
        {
            "location": "/projects/shamballs/#files",
            "text": "Game Design Document  Techinical Design Document",
            "title": "Files"
        },
        {
            "location": "/projects/shamballs/#references",
            "text": "Audacityteam.org. (2016). Audacity\u00ae.  \nAvailable at: http://www.audacityteam.org/  Fmod.org. (2016). FMOD. \nAvailable at: http://www.fmod.org/  GitHub. (2016). Microsoft/DirectXTK. \nAvailable at: https://github.com/Microsoft/DirectXTK/  Docs.nvidia.com. (2016). NVIDIA\u00ae PhysX\u00ae SDK 3.3.4 Documentation \u2014 NVIDIA PhysX SDK 3.3.4 Documentation.\nAvailable at:  http://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Index.html  Jenkinssoftware.com. (2016). RakNet - Multiplayer game network engine. \nAvailable at: http://www.jenkinssoftware.com/",
            "title": "References"
        },
        {
            "location": "/projects/shamballs/#code-snippet",
            "text": "Resource Manager:  #include \"pch.h\"\n\n#include \"ResourceManager.h\"\n#include \"Engine.h\"\n\nResourceManager::ResourceManager()\n{\n    Initialize();\n}\n\nResourceManager::~ResourceManager()\n{\n    //Delete all sounds from m_SoundList\n    std::map<SoundName::SoundName, Sound*>::iterator itr = m_SoundMap.begin();\n    while (itr != m_SoundMap.end()){\n        itr->second->release();\n        ++itr;\n    }\n    m_SoundMap.clear();\n\n    //Delete textures\n    std::map<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>::iterator titr = m_TextureMap.begin();\n    while (titr != m_TextureMap.end()){\n        titr->second->Get()->Release();\n        ++titr;\n    }\n    m_TextureMap.clear();\n}\n\nbool ResourceManager::Initialize()\n{\n    //Load sounds, and add to sound map.\n\n    //Countdown\n    Sound* countdown;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\countdown.mp3\", FMOD_DEFAULT, 0, &countdown);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::COUNTDOWN, countdown));\n\n    //Menu\n    Sound* menuclick;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\menuclick.wav\", FMOD_DEFAULT, 0, &menuclick);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::MENUCLICK, menuclick));\n\n    Sound* menuscroll;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\menuscroll.wav\", FMOD_DEFAULT, 0, &menuscroll);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::MENUSCROLL, menuscroll));\n\n    //Player sounds\n    Sound* boostsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\boostsound.wav\", FMOD_DEFAULT, 0, &boostsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::BOOSTSOUND, boostsound));\n\n    Sound* growsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\growsound.mp3\", FMOD_DEFAULT, 0, &growsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::GROWSOUND, growsound));\n\n    Sound* shrinksound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\shrinksound.mp3\", FMOD_DEFAULT, 0, &shrinksound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::SHRINKSOUND, shrinksound));\n\n    Sound* pickupsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\pickupsound.mp3\", FMOD_DEFAULT, 0, &pickupsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::PICKUP, pickupsound));\n\n    Sound* jumpsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\jumpsound.mp3\", FMOD_DEFAULT, 0, &jumpsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::JUMP, jumpsound));\n\n    Sound* landsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\landsound.wav\", FMOD_DEFAULT, 0, &landsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::LAND, landsound));\n\n    Sound* playermovementsound;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\playermovementsound.wav\", FMOD_DEFAULT, 0, &playermovementsound);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::PLAYERMOVEMENT, playermovementsound));\n\n    //Background music\n    Sound* backgroundmusic;\n    Engine::GetInstance().m_SoundSystem->createSound(\"Assets\\\\Sounds\\\\backgroundmusic.mp3\", FMOD_DEFAULT, 0, &backgroundmusic);\n    m_SoundMap.insert(std::pair<SoundName::SoundName, Sound*>(SoundName::BACKGROUND, backgroundmusic));\n\n    //Load texture, and add to sound map.\n    //Wood texutre\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* woodTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\woodtexture.png\", nullptr, woodTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::WOOD, woodTexture));\n\n    //Concrete texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* concreteTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\concretetexture.png\", nullptr, concreteTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::CONCRETE, concreteTexture));\n\n    //Steel texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* steelTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\steeltexture.png\", nullptr, steelTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::STEEL, steelTexture));\n\n    //Boost texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* pickupTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\pickuptexture.png\", nullptr, pickupTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::PICKUP, pickupTexture));\n\n    //Sky Texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* skyTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\skytexture.png\", nullptr, skyTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::SKY, skyTexture));\n\n    //Finish Texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* finishTexture = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\finish.png\", nullptr, finishTexture->GetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::FINISH, finishTexture));\n\n    //ICONS\n    //Cursor\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* cursoricon = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\cursor.png\", nullptr, cursoricon->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::CURSOR, cursoricon));\n\n    //Boost Icon Texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* boostIcon = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\boosticon64.png\", nullptr, boostIcon->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::BOOST, boostIcon));\n\n    //Grow Icon Texture\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* growicon = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\growicon64.png\", nullptr, growicon->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::GROW, growicon));\n\n    //DERBY ICONS\n    //connected icon\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* connected = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\connected.png\", nullptr, connected->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::CONNECTED, connected));\n    //not connected icon\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* notconnected = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\notconnected.png\", nullptr, notconnected->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::NOTCONNECTED, notconnected));\n    //connect button\n    Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>* connectbutton = new Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>();\n    DX::ThrowIfFailed(CreateWICTextureFromFile(Engine::GetInstance().m_d3dDevice.Get(), L\"Assets\\\\Textures\\\\connectbutton.png\", nullptr, connectbutton->ReleaseAndGetAddressOf()));\n    m_TextureMap.insert(std::pair<TextureName::TextureName, Microsoft::WRL::ComPtr<ID3D11ShaderResourceView>*>(TextureName::CONNECT, connectbutton));\n\n    return true;\n}",
            "title": "Code Snippet"
        },
        {
            "location": "/contact/",
            "text": "Contact\n\n\nPhone\n\n\n021 103 9870\n\n\nEmail\n\n\nsmchambers95@gmail.com\n\n\nSocial Media",
            "title": "Contact"
        },
        {
            "location": "/contact/#contact",
            "text": "",
            "title": "Contact"
        },
        {
            "location": "/contact/#phone",
            "text": "021 103 9870",
            "title": "Phone"
        },
        {
            "location": "/contact/#email",
            "text": "smchambers95@gmail.com",
            "title": "Email"
        },
        {
            "location": "/contact/#social-media",
            "text": "",
            "title": "Social Media"
        }
    ]
}